<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libcppa: libcppa&#39;s platform-independent type system.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libcppa
   &#160;<span id="projectnumber">Version 0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">libcppa's platform-independent type system.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1deserializer.html">cppa::deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent deserialization interface.  <a href="classcppa_1_1deserializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1primitive__variant.html">cppa::primitive_variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An union container for primitive data types.  <a href="classcppa_1_1primitive__variant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1serializer.html">cppa::serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent serialization interface.  <a href="classcppa_1_1serializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1uniform__type__info.html">cppa::uniform_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a platform independent type name and a (very primitive) kind of reflection in combination with <a class="el" href="classcppa_1_1object.html">object</a>.  <a href="classcppa_1_1uniform__type__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga4405c08180f3db0936dcc6afe84f2899"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">cppa::primitive_type</a> : unsigned char { <br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899af3b4cd07f6e7b784ef327226d125f081">cppa::pt_int8</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899abe2fbca2e1841f8c22880cde2c00f542">cppa::pt_int16</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899aa0a3077bf98838f8565a3081bd45fe7a">cppa::pt_int32</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899adb00d323a0719b09a9b1e2b296bf7ee7">cppa::pt_int64</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a88cb8022596d4673fede279849a67c9e">cppa::pt_uint8</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ac2fefdb86c724a8fccdaf77295bdb786">cppa::pt_uint16</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a081be63f60008807f9a07df1d814704a">cppa::pt_uint32</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a05e7b1ff7b99a9f24ff8a44577745d59">cppa::pt_uint64</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a9c2885b0dd3095de04714bf6d791ed61">cppa::pt_float</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a840b02ba715ef3b798d3f1b6cb1dd1bc">cppa::pt_double</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899afaa2282a22514a0934a3571b4e4cc75d">cppa::pt_long_double</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a93531ba3275cbc0a4cfcb23a6bbe080e">cppa::pt_u8string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ab2a366dcc7a5b7ee1162fd024d6f722e">cppa::pt_u16string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ac04250078e159cbbb285ad3a39aae4ce">cppa::pt_u32string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a8b7d0c7bdeab0ac7b90d756827b95cb4">cppa::pt_atom</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a494ed640f1e094e7db23a9ce2f3f199b">cppa::pt_null</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga4405c08180f3db0936dcc6afe84f2899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type flag of <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a>.  <a href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">More...</a><br/></td></tr>
<tr class="separator:ga4405c08180f3db0936dcc6afe84f2899"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5168c92d6bb51d74f61cea1253940cd6"><td class="memItemLeft" align="right" valign="top">const uniform_type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga5168c92d6bb51d74f61cea1253940cd6">cppa::announce</a> (const std::type_info &amp;tinfo, std::unique_ptr&lt; uniform_type_info &gt; utype)</td></tr>
<tr class="memdesc:ga5168c92d6bb51d74f61cea1253940cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping to the libcppa type system.  <a href="#ga5168c92d6bb51d74f61cea1253940cd6">More...</a><br/></td></tr>
<tr class="separator:ga5168c92d6bb51d74f61cea1253940cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , typename... Ts&gt; </td></tr>
<tr class="memitem:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C Parent::*, <br class="typebreak"/>
util::abstract_uniform_type_info<br class="typebreak"/>
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#gaf92877da942d1a0f1944990cd3d67f7c">cppa::compound_member</a> (C Parent::*c_ptr, const Ts &amp;...args)</td></tr>
<tr class="memdesc:gaf92877da942d1a0f1944990cd3d67f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member <code>C</code>.  <a href="#gaf92877da942d1a0f1944990cd3d67f7c">More...</a><br/></td></tr>
<tr class="separator:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , typename... Ts&gt; </td></tr>
<tr class="memitem:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C &amp;(Parent::*)(), <br class="typebreak"/>
util::abstract_uniform_type_info<br class="typebreak"/>
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#gaf1400abaf4c109b60eba1f83d417b65c">cppa::compound_member</a> (C &amp;(Parent::*getter)(), const Ts &amp;...args)</td></tr>
<tr class="memdesc:gaf1400abaf4c109b60eba1f83d417b65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member accessed via a getter returning a mutable reference.  <a href="#gaf1400abaf4c109b60eba1f83d417b65c">More...</a><br/></td></tr>
<tr class="separator:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="memTemplParams" colspan="2">template&lt;class Parent , typename GRes , typename SRes , typename SArg , typename... Ts&gt; </td></tr>
<tr class="memitem:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; GRes(Parent::*)() <br class="typebreak"/>
const, SRes(Parent::*)(SArg)&gt;<br class="typebreak"/>
, util::abstract_uniform_type_info<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
util::rm_const_and_ref&lt; GRes &gt;<br class="typebreak"/>
::type &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga8f1d70c1c395b02cf3b668fbe103a593">cppa::compound_member</a> (const std::pair&lt; GRes(Parent::*)() const, SRes(Parent::*)(SArg) &gt; &amp;gspair, const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member accessed via a getter/setter pair.  <a href="#ga8f1d70c1c395b02cf3b668fbe103a593">More...</a><br/></td></tr>
<tr class="separator:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="memTemplParams" colspan="2">template&lt;class C , typename... Ts&gt; </td></tr>
<tr class="memitem:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="memTemplItemLeft" align="right" valign="top">const uniform_type_info *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga855b3b9aeeb091f8f7db15fb0e012fb8">cppa::announce</a> (const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping for <code>C</code> to the libcppa type system.  <a href="#ga855b3b9aeeb091f8f7db15fb0e012fb8">More...</a><br/></td></tr>
<tr class="separator:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2534a2a021d60eaa4519e36714d435af"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2534a2a021d60eaa4519e36714d435af"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ga2534a2a021d60eaa4519e36714d435af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga2534a2a021d60eaa4519e36714d435af">cppa::announce_tuple</a> ()</td></tr>
<tr class="memdesc:ga2534a2a021d60eaa4519e36714d435af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a hint to the type system of libcppa. This type hint can increase the network performance, because libcppa can use the hint to create tuples with full static type information rather than using fully dynamically typed tuples. <br/></td></tr>
<tr class="separator:ga2534a2a021d60eaa4519e36714d435af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga5d1de7bc77d88156d0e12e373ab2c613">cppa::primitive_type_name</a> (<a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">primitive_type</a> ptype)</td></tr>
<tr class="memdesc:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899" title="Represents the type flag of primitive_variant. ">primitive_type</a> value to its name.  <a href="#ga5d1de7bc77d88156d0e12e373ab2c613">More...</a><br/></td></tr>
<tr class="separator:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a8f475d1b708c6d70598370ba92d8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga22a8f475d1b708c6d70598370ba92d8f"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga22a8f475d1b708c6d70598370ba92d8f">get</a> (const primitive_variant &amp;pv)</td></tr>
<tr class="memdesc:ga22a8f475d1b708c6d70598370ba92d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a primitive variant to its C++ type.  <a href="#ga22a8f475d1b708c6d70598370ba92d8f">More...</a><br/></td></tr>
<tr class="separator:ga22a8f475d1b708c6d70598370ba92d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga933cd1117131023bed7812fa237a42fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga933cd1117131023bed7812fa237a42fd"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga933cd1117131023bed7812fa237a42fd">get_ref</a> (primitive_variant &amp;pv)</td></tr>
<tr class="memdesc:ga933cd1117131023bed7812fa237a42fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a non-const primitive variant to its C++ type.  <a href="#ga933cd1117131023bed7812fa237a42fd">More...</a><br/></td></tr>
<tr class="separator:ga933cd1117131023bed7812fa237a42fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><code>libcppa</code> provides a fully network transparent communication between actors. Thus, <code>libcppa</code> needs to serialize and deserialize message objects. Unfortunately, this is not possible using the C++ RTTI system.</p>
<p>Since it is not possible to extend <code>std::type_info</code>, <code>libcppa</code> uses its own type abstraction: <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a>.</p>
<p>Unlike <code>std::type_info::name()</code>, <a class="el" href="classcppa_1_1uniform__type__info.html#a566901995f5850eac0fb9aa449fe00e5">uniform_type_info::name()</a> is guaranteed to return the same name on all supported platforms. Furthermore, it allows to create an instance of a type by name:</p>
<div class="fragment"><div class="line">* <span class="comment">// creates a signed, 32 bit integer</span></div>
<div class="line">* <a class="code" href="classcppa_1_1object.html">cppa::object</a> i = cppa::uniform_type_info::by_name(<span class="stringliteral">&quot;@i32&quot;</span>)-&gt;create();</div>
<div class="line">* </div>
</div><!-- fragment --><p>However, you should rarely if ever need to use <a class="el" href="classcppa_1_1object.html">object</a> or <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a>.</p>
<p>There is one exception, though, where you need to care about <code>libcppa</code>'s type system: using custom data types in messages. The source code below compiles fine, but crashes with an exception during runtime.</p>
<div class="fragment"><div class="line">* #include <span class="stringliteral">&quot;cppa/cppa.hpp&quot;</span></div>
<div class="line">* <span class="keyword">using namespace </span>cppa;</div>
<div class="line">*</div>
<div class="line">* <span class="keyword">struct </span>foo { <span class="keywordtype">int</span> a; <span class="keywordtype">int</span> b; };</div>
<div class="line">*</div>
<div class="line">* <span class="keywordtype">int</span> main()</div>
<div class="line">* {</div>
<div class="line">*     send(<span class="keyword">self</span>, foo{1, 2});</div>
<div class="line">*     <span class="keywordflow">return</span> 0;</div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --><p>Depending on your platform, the error message looks somewhat like this:</p>
<p><code> terminate called after throwing an instance of std::runtime_error <br/>
 what(): uniform_type_info::by_type_info(): foo is an unknown typeid name </code></p>
<p>The user-defined struct <code>foo</code> is not known by the <code>libcppa</code> type system. Thus, <code>libcppa</code> is unable to serialize/deserialize <code>foo</code> and rejects it.</p>
<p>Fortunately, there is an easy way to add <code>foo</code> the type system, without needing to implement serialize/deserialize by yourself:</p>
<div class="fragment"><div class="line">* cppa::announce&lt;foo&gt;(&amp;foo::a, &amp;foo::b);</div>
<div class="line">* </div>
</div><!-- fragment --><p><a class="el" href="group___type_system.html#ga5168c92d6bb51d74f61cea1253940cd6">announce()</a> takes the class as template parameter and pointers to all members (or getter/setter pairs) as arguments. This works for all primitive data types and STL compliant containers. See the announce <a class="el" href="">example 1</a>, <a class="el" href="">example 2</a>, <a class="el" href="">example 3</a> and <a class="el" href="">example 4</a> for more details.</p>
<p>Obviously, there are limitations. If your class does implement an unsupported data structure, you have to implement serialize/deserialize by yourself. <a class="el" href="">Example 5</a> shows, how to announce a tree data structure to the <code>libcppa</code> type system. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga4405c08180f3db0936dcc6afe84f2899"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum primitive_type : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the type flag of <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a>. </p>
<p>Includes integers (signed and unsigned), floating points and strings (std::string, std::u16string and std::u32string). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899af3b4cd07f6e7b784ef327226d125f081"></a>pt_int8</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::int8_t</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899abe2fbca2e1841f8c22880cde2c00f542"></a>pt_int16</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::int16_t</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899aa0a3077bf98838f8565a3081bd45fe7a"></a>pt_int32</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::int32_t</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899adb00d323a0719b09a9b1e2b296bf7ee7"></a>pt_int64</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::int64_t</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899a88cb8022596d4673fede279849a67c9e"></a>pt_uint8</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::uint8_t</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899ac2fefdb86c724a8fccdaf77295bdb786"></a>pt_uint16</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::uint16_t</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899a081be63f60008807f9a07df1d814704a"></a>pt_uint32</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::uint32_t</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899a05e7b1ff7b99a9f24ff8a44577745d59"></a>pt_uint64</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::uint64_t</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899a9c2885b0dd3095de04714bf6d791ed61"></a>pt_float</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>float</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899a840b02ba715ef3b798d3f1b6cb1dd1bc"></a>pt_double</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>double</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899afaa2282a22514a0934a3571b4e4cc75d"></a>pt_long_double</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>long double</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899a93531ba3275cbc0a4cfcb23a6bbe080e"></a>pt_u8string</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::string</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899ab2a366dcc7a5b7ee1162fd024d6f722e"></a>pt_u16string</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::u16string</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899ac04250078e159cbbb285ad3a39aae4ce"></a>pt_u32string</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>std::u32string</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899a8b7d0c7bdeab0ac7b90d756827b95cb4"></a>pt_atom</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>atom_value</code> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4405c08180f3db0936dcc6afe84f2899a494ed640f1e094e7db23a9ce2f3f199b"></a>pt_null</em>&nbsp;</td><td class="fielddoc">
<p>equivalent of <code>void</code> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5168c92d6bb51d74f61cea1253940cd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uniform_type_info* cppa::announce </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>tinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; uniform_type_info &gt;&#160;</td>
          <td class="paramname"><em>utype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new type mapping to the libcppa type system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tinfo</td><td>C++ RTTI for the new type </td></tr>
    <tr><td class="paramname">utype</td><td>Corresponding <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>uniform_type</code> was added as known instance (mapped to <code>plain_type</code>); otherwise <code>false</code> is returned and <code>uniform_type</code> was deleted. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_5_8cpp-example.html#a12">announce_5.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga855b3b9aeeb091f8f7db15fb0e012fb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const uniform_type_info* cppa::announce </td>
          <td>(</td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new type mapping for <code>C</code> to the libcppa type system. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>A class that is either empty or is default constructible, copy constructible, and comparable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Members of <code>C</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><code>announce</code> is <b>not</b> thead safe! </dd></dl>

</div>
</div>
<a class="anchor" id="gaf92877da942d1a0f1944990cd3d67f7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class Parent , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;C Parent::*, util::abstract_uniform_type_info&lt;C&gt;*&gt; cppa::compound_member </td>
          <td>(</td>
          <td class="paramtype">C Parent::*&#160;</td>
          <td class="paramname"><em>c_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates meta informations for a non-trivial member <code>C</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_ptr</td><td>Pointer to the non-trivial member. </td></tr>
    <tr><td class="paramname">args</td><td>"Sub-members" of <code>c_ptr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="announce_4_8cpp-example.html">announce example 4</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of <code>c_ptr</code> and the created meta informations. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_4_8cpp-example.html#a4">announce_4.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaf1400abaf4c109b60eba1f83d417b65c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class Parent , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;C&amp; (Parent::*)(), util::abstract_uniform_type_info&lt;C&gt;*&gt; cppa::compound_member </td>
          <td>(</td>
          <td class="paramtype">C &amp;(Parent::*)()&#160;</td>
          <td class="paramname"><em>getter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates meta informations for a non-trivial member accessed via a getter returning a mutable reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">getter</td><td>Member function pointer to the getter. </td></tr>
    <tr><td class="paramname">args</td><td>"Sub-members" of <code>c_ptr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="announce_4_8cpp-example.html">announce example 4</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of <code>c_ptr</code> and the created meta informations. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f1d70c1c395b02cf3b668fbe103a593"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Parent , typename GRes , typename SRes , typename SArg , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::pair&lt;GRes (Parent::*)() const, SRes (Parent::*)(SArg)&gt;, util::abstract_uniform_type_info&lt;typename util::rm_const_and_ref&lt;GRes&gt;::type&gt;*&gt; cppa::compound_member </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; GRes(Parent::*)() const, SRes(Parent::*)(SArg) &gt; &amp;&#160;</td>
          <td class="paramname"><em>gspair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates meta informations for a non-trivial member accessed via a getter/setter pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gspair</td><td>A pair of two member function pointers representing getter and setter. </td></tr>
    <tr><td class="paramname">args</td><td>"Sub-members" of <code>c_ptr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="announce_4_8cpp-example.html">announce example 4</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of <code>c_ptr</code> and the created meta informations. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22a8f475d1b708c6d70598370ba92d8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a> &amp;&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a primitive variant to its C++ type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>A primitive variant of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the value of <code>pv</code> of type <code>T</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>pv</code> is not of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga933cd1117131023bed7812fa237a42fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; get_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a> &amp;&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a non-const primitive variant to its C++ type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>A primitive variant of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the value of <code>pv</code> of type <code>T</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>pv</code> is not of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5d1de7bc77d88156d0e12e373ab2c613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* cppa::primitive_type_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">primitive_type</a>&#160;</td>
          <td class="paramname"><em>ptype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a <a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899" title="Represents the type flag of primitive_variant. ">primitive_type</a> value to its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptype</td><td>Requestet <code>primitive_type</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C-string representation of <code>ptype</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 4 2014 23:48:00 for libcppa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
