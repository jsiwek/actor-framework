<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>libcaf: caf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libcaf
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">caf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Root namespace of libcaf.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecaf_1_1exit__reason"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1exit__reason.html">exit_reason</a></td></tr>
<tr class="memdesc:namespacecaf_1_1exit__reason"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all predefined exit reasons. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecaf_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1io.html">io</a></td></tr>
<tr class="memdesc:namespacecaf_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all network-related classes and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecaf_1_1mixin"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1mixin.html">mixin</a></td></tr>
<tr class="memdesc:namespacecaf_1_1mixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains mixin classes implementing several actor traits. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecaf_1_1policy"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1policy.html">policy</a></td></tr>
<tr class="memdesc:namespacecaf_1_1policy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains policies encapsulating characteristics or algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1abstract__actor.html">abstract_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all actor implementations.  <a href="classcaf_1_1abstract__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1abstract__channel.html">abstract_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all message receivers.  <a href="classcaf_1_1abstract__channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1abstract__group.html">abstract_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multicast group.  <a href="classcaf_1_1abstract__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor.html">actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an untyped actor.  <a href="classcaf_1_1actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the address of typed as well as untyped actors.  <a href="classcaf_1_1actor__addr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__companion.html">actor_companion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An co-existing forwarding all messages through a user-defined callback to another object, thus serving as gateway to allow any object to interact with other actors.  <a href="classcaf_1_1actor__companion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__exited.html">actor_exited</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown if an actor finished execution.  <a href="classcaf_1_1actor__exited.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__namespace.html">actor_namespace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups a (distributed) set of actors and allows actors in the same namespace to exchange messages.  <a href="classcaf_1_1actor__namespace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__proxy.html">actor_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a remote actor.  <a href="classcaf_1_1actor__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1anything.html">anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acts as wildcard expression in patterns.  <a href="structcaf_1_1anything.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1attachable.html">attachable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback utility class.  <a href="classcaf_1_1attachable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1behavior.html">behavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the behavior of an actor, i.e., provides a message handler and an optional timeout.  <a href="classcaf_1_1behavior.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1binary__deserializer.html">binary_deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the deserializer interface with a binary serialization protocol.  <a href="classcaf_1_1binary__deserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1binary__serializer.html">binary_serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the serializer interface with a binary serialization protocol.  <a href="classcaf_1_1binary__serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1bind__failure.html">bind_failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate that an actor publishing failed because the requested port could not be used.  <a href="classcaf_1_1bind__failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1blocking__actor.html">blocking_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread-mapped or context-switching actor using a blocking receive rather than a behavior-stack based message processing.  <a href="classcaf_1_1blocking__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1blocking__response__handle__tag.html">blocking_response_handle_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tag identifies response handles featuring a blocking API by providing an <code>await</code> member function.  <a href="structcaf_1_1blocking__response__handle__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1caf__exception.html">caf_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for exceptions.  <a href="classcaf_1_1caf__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1channel.html">channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to instances of <code><a class="el" href="classcaf_1_1abstract__channel.html" title="Interface for all message receivers. ">abstract_channel</a></code>.  <a href="classcaf_1_1channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1continue__helper.html">continue_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to enable users to add continuations when dealing with synchronous sends.  <a href="classcaf_1_1continue__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1deserializer.html">deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent deserialization interface.  <a href="classcaf_1_1deserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1down__msg.html">down_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent to all actors monitoring an actor when it is terminated.  <a href="structcaf_1_1down__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1duration.html">duration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time duration consisting of a <code>time_unit</code> and a 64 bit unsigned integer.  <a href="classcaf_1_1duration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1event__based__actor.html">event_based_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cooperatively scheduled, event-based actor implementation.  <a href="classcaf_1_1event__based__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1execution__unit.html">execution_unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an execution unit, e.g., a worker thread of the scheduler.  <a href="classcaf_1_1execution__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1exit__msg.html">exit_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent to all links when an actor is terminated.  <a href="structcaf_1_1exit__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1extend.html">extend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows convenient definition of types using mixins.  <a href="structcaf_1_1extend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1functor__based__typed__actor.html">functor_based_typed_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for strongly typed actors using a functor-based implementation.  <a href="classcaf_1_1functor__based__typed__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1group__down__msg.html">group_down_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent to all members of a group when it goes offline.  <a href="structcaf_1_1group__down__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1handle.html">handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for IO handles such as <code>accept_handle</code> or <code>connection_handle</code>.  <a href="classcaf_1_1handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1infer__typed__actor__base.html">infer_typed_actor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infers the appropriate base class for a functor-based typed actor from the result and the first argument of the functor.  <a href="structcaf_1_1infer__typed__actor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive, reference counting smart pointer impelementation.  <a href="classcaf_1_1intrusive__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1is__same__ish.html">is_same_ish</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>T</code> to <code>U</code> und evaluates to <code>true_type</code> if either `T == U or if T and U are both integral types of the same size and signedness.  <a href="structcaf_1_1is__same__ish.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1local__actor.html">local_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for local running Actors.  <a href="classcaf_1_1local__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1match__expr.html">match_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A match expression encapsulating cases <code>Cs..., whereas each case is a</code>detail::match_expr_case&lt;`...&gt;.  <a href="classcaf_1_1match__expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1memory__managed.html">memory_managed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base enables derived classes to enforce a different allocation strategy than new/delete by providing a virtual protected <code><a class="el" href="classcaf_1_1memory__managed.html#a9fa5cd0c7cb1d3c960951b1d45ed7af6" title="Default implementations calls `delete this, but can be overriden in case deletion depends on some con...">request_deletion()</a></code> function and non-public destructor.  <a href="classcaf_1_1memory__managed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1message.html">message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a fixed-length copy-on-write tuple with elements of any type.  <a href="classcaf_1_1message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1message__builder.html">message_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a convenient interface to create a <a class="el" href="classcaf_1_1message.html">message</a> from a series of values using the member function <code>append</code>.  <a href="classcaf_1_1message__builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1message__handler.html">message_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial function implementation used to process a <code>message</code>.  <a href="classcaf_1_1message__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1message__id.html">message_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes whether a message is asynchronous or synchronous.  <a href="classcaf_1_1message__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1network__error.html">network_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate that either an actor publishing failed or the middleman was unable to connect to a remote host.  <a href="classcaf_1_1network__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1node__id.html">node_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node ID consists of a host ID and process ID.  <a href="classcaf_1_1node__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1nonblocking__response__handle__tag.html">nonblocking_response_handle_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tag identifies response handles featuring a nonblocking API by providing a <code>then</code> member function.  <a href="structcaf_1_1nonblocking__response__handle__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an optional value of <code>T</code>.  <a href="classcaf_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1optional_3_01_t_01_6_01_4.html">optional&lt; T &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization to allow <code>optional</code> to hold a reference rather than an actual value.  <a href="classcaf_1_1optional_3_01_t_01_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1ref__counted.html">ref_counted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for reference counted objects with an atomic reference count.  <a href="classcaf_1_1ref__counted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1response__handle.html">response_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper class identifies an expected response message and enables <code>sync_send(...).then(...)</code>.  <a href="classcaf_1_1response__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1response__promise.html">response_promise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A response promise can be used to deliver a uniquely identifiable response message from the server (i.e.  <a href="classcaf_1_1response__promise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1resumable.html">resumable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cooperatively executed task managed by one or more instances of <code><a class="el" href="classcaf_1_1execution__unit.html" title="Identifies an execution unit, e.g., a worker thread of the scheduler. ">execution_unit</a></code>.  <a href="classcaf_1_1resumable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1sb__actor.html">sb_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for state-based actors using the Curiously Recurring Template Pattern to initialize the derived actor with its <code>init_state</code> member.  <a href="classcaf_1_1sb__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1scoped__actor.html">scoped_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scoped handle to a blocking actor.  <a href="classcaf_1_1scoped__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1serializer.html">serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent serialization interface.  <a href="classcaf_1_1serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1single__timeout.html">single_timeout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin for actors using a non-nestable message processing.  <a href="classcaf_1_1single__timeout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1skip__message__t.html">skip_message_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional return type for functors used in pattern matching expressions.  <a href="structcaf_1_1skip__message__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1spawn__as__is.html">spawn_as_is</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker interface that prevents <code>spawn</code> from wrapping the a class in a <code>proper_actor</code> when spawning new instances.  <a href="classcaf_1_1spawn__as__is.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1spawn__options.html">spawn_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores options passed to the <code>spawn</code> function family.  <a href="classcaf_1_1spawn__options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1sync__exited__msg.html">sync_exited_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent whenever a terminated actor receives a synchronous request.  <a href="structcaf_1_1sync__exited__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1sync__timeout__msg.html">sync_timeout_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent whenever a timeout occurs during a synchronous send.  <a href="structcaf_1_1sync__timeout__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1timeout__msg.html">timeout_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signalizes a timeout event.  <a href="structcaf_1_1timeout__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1typed__actor.html">typed_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a strongly typed actor.  <a href="classcaf_1_1typed__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1typed__event__based__actor.html">typed_event_based_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cooperatively scheduled, event-based actor implementation with strong type checking.  <a href="classcaf_1_1typed__event__based__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1uniform__type__info.html">uniform_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a platform independent type name and a (very primitive) kind of reflection in combination with <a class="el" href="">object</a>.  <a href="classcaf_1_1uniform__type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1variant.html">variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant represents always a valid value of one of the types <code>Ts...</code>.  <a href="classcaf_1_1variant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a927c5c9b74ac4d1dde0cc06ff25888f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a927c5c9b74ac4d1dde0cc06ff25888f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>abstract_actor_ptr</b> = <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcaf_1_1abstract__actor.html">abstract_actor</a> &gt;</td></tr>
<tr class="separator:a927c5c9b74ac4d1dde0cc06ff25888f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438b3db19c6279a82c6227ac2c70f47a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a438b3db19c6279a82c6227ac2c70f47a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>keep_behavior_t</b> = behavior_policy&lt; false &gt;</td></tr>
<tr class="separator:a438b3db19c6279a82c6227ac2c70f47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c31ae0a89a8029f5e69266ec3343336"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c31ae0a89a8029f5e69266ec3343336"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>discard_behavior_t</b> = behavior_policy&lt; true &gt;</td></tr>
<tr class="separator:a5c31ae0a89a8029f5e69266ec3343336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019858c90690e095b228487d83996927"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a019858c90690e095b228487d83996927"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>abstract_group_ptr</b> = uint64_t <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcaf_1_1abstract__group.html">abstract_group</a> &gt;</td></tr>
<tr class="separator:a019858c90690e095b228487d83996927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c1a5caff6cca08869229be659b2d65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5c1a5caff6cca08869229be659b2d65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>actor_proxy_ptr</b> = <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcaf_1_1actor__proxy.html">actor_proxy</a> &gt;</td></tr>
<tr class="separator:ac5c1a5caff6cca08869229be659b2d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4b2c9c7f5ed5081d423fc5b1d51a51"><td class="memTemplParams" colspan="2"><a class="anchor" id="aec4b2c9c7f5ed5081d423fc5b1d51a51"></a>
template&lt;class Lockable &gt; </td></tr>
<tr class="memitem:aec4b2c9c7f5ed5081d423fc5b1d51a51"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unique_lock</b> = std::unique_lock&lt; Lockable &gt;</td></tr>
<tr class="separator:aec4b2c9c7f5ed5081d423fc5b1d51a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfffd87163ddb43a655a337922d3882b"><td class="memTemplParams" colspan="2"><a class="anchor" id="abfffd87163ddb43a655a337922d3882b"></a>
template&lt;class SharedLockable &gt; </td></tr>
<tr class="memitem:abfffd87163ddb43a655a337922d3882b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upgrade_lock</b> = shared_lock&lt; SharedLockable &gt;</td></tr>
<tr class="separator:abfffd87163ddb43a655a337922d3882b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a635d91df2f328e65cf68f37bb6b6ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a635d91df2f328e65cf68f37bb6b6ac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>unique_mailbox_element_pointer</b> = std::unique_ptr&lt; mailbox_element, detail::disposer &gt;</td></tr>
<tr class="separator:a1a635d91df2f328e65cf68f37bb6b6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d30951ba19de463aa73aced63bfecd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8d30951ba19de463aa73aced63bfecd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>primitive_variant</b> = <a class="el" href="classcaf_1_1variant.html">variant</a>&lt; int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t, float, double, long double, std::string, std::u16string, std::u32string, <a class="el" href="namespacecaf.html#a6328c86a49e5f378b7b08711879dc8e7">atom_value</a> &gt;</td></tr>
<tr class="separator:af8d30951ba19de463aa73aced63bfecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97391cd7f039a506e3f31aa35bdf116c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97391cd7f039a506e3f31aa35bdf116c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>generic_timeout_definition</b> = timeout_definition&lt; std::function&lt; void()&gt;&gt;</td></tr>
<tr class="separator:a97391cd7f039a506e3f31aa35bdf116c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8a2c96aa2b59dbc3cf0a9de848a9a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc8a2c96aa2b59dbc3cf0a9de848a9a7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>uniform_value</b> = std::unique_ptr&lt; uniform_value_t &gt;</td></tr>
<tr class="separator:abc8a2c96aa2b59dbc3cf0a9de848a9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d59040eecfce604123d9cf01ac225d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d59040eecfce604123d9cf01ac225d8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>uniform_type_info_ptr</b> = std::unique_ptr&lt; <a class="el" href="classcaf_1_1uniform__type__info.html">uniform_type_info</a> &gt;</td></tr>
<tr class="separator:a9d59040eecfce604123d9cf01ac225d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6328c86a49e5f378b7b08711879dc8e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6328c86a49e5f378b7b08711879dc8e7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a6328c86a49e5f378b7b08711879dc8e7">atom_value</a> : uint64_t </td></tr>
<tr class="memdesc:a6328c86a49e5f378b7b08711879dc8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type of atoms. <br /></td></tr>
<tr class="separator:a6328c86a49e5f378b7b08711879dc8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7952a6b8fa7dd2b9e6b750b11f3e58f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7952a6b8fa7dd2b9e6b750b11f3e58f8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a7952a6b8fa7dd2b9e6b750b11f3e58f8">time_unit</a> : uint32_t { <br />
&#160;&#160;<b>invalid</b> = 0, 
<br />
&#160;&#160;<b>seconds</b> = 1, 
<br />
&#160;&#160;<b>milliseconds</b> = 1000, 
<br />
&#160;&#160;<b>microseconds</b> = 1000000
<br />
 }</td></tr>
<tr class="memdesc:a7952a6b8fa7dd2b9e6b750b11f3e58f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI time units to specify timeouts. <br /></td></tr>
<tr class="separator:a7952a6b8fa7dd2b9e6b750b11f3e58f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b21dabe60a979a70093a03d810ff2d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b21dabe60a979a70093a03d810ff2d8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>message_priority</b> : uint32_t { <br />
&#160;&#160;<b>normal</b>, 
<br />
&#160;&#160;<b>high</b>
<br />
 }</td></tr>
<tr class="separator:a8b21dabe60a979a70093a03d810ff2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee60fa2e31e2403d555e38db286eb40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ee60fa2e31e2403d555e38db286eb40"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a3ee60fa2e31e2403d555e38db286eb40">wildcard_position</a> { <br />
&#160;&#160;<b>nil</b>, 
<br />
&#160;&#160;<b>trailing</b>, 
<br />
&#160;&#160;<b>leading</b>, 
<br />
&#160;&#160;<b>in_between</b>, 
<br />
&#160;&#160;<b>multiple</b>
<br />
 }</td></tr>
<tr class="memdesc:a3ee60fa2e31e2403d555e38db286eb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes the position of <code>anything</code> in a template parameter pack. <br /></td></tr>
<tr class="separator:a3ee60fa2e31e2403d555e38db286eb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2844a098da6c4d147100dfe8496121f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2844a098da6c4d147100dfe8496121f3"></a>
template&lt;class T , typename U &gt; </td></tr>
<tr class="memitem:a2844a098da6c4d147100dfe8496121f3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a2844a098da6c4d147100dfe8496121f3">actor_cast</a> (const U &amp;what)</td></tr>
<tr class="memdesc:a2844a098da6c4d147100dfe8496121f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts actor handle <code>what</code> to a different actor handle of type <code>T</code>. <br /></td></tr>
<tr class="separator:a2844a098da6c4d147100dfe8496121f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5b3177242ca2a8827e9dc12f73d01b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb5b3177242ca2a8827e9dc12f73d01b"></a>
actor_ostream&#160;</td><td class="memItemRight" valign="bottom"><b>aout</b> (<a class="el" href="classcaf_1_1actor.html">actor</a> self)</td></tr>
<tr class="separator:afb5b3177242ca2a8827e9dc12f73d01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a235a4d217d39344a45f105964f885"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcaf_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga34a235a4d217d39344a45f105964f885">announce</a> (const std::type_info &amp;tinfo, uniform_type_info_ptr utype)</td></tr>
<tr class="memdesc:ga34a235a4d217d39344a45f105964f885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new mapping to the type system.  <a href="group___type_system.html#ga34a235a4d217d39344a45f105964f885">More...</a><br /></td></tr>
<tr class="separator:ga34a235a4d217d39344a45f105964f885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9f772e0bf4d244c27177c53f73ed24"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , class... Ts&gt; </td></tr>
<tr class="memitem:ga0b9f772e0bf4d244c27177c53f73ed24"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C Parent::*, <br class="typebreak" />
detail::abstract_uniform_type_info<br class="typebreak" />
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga0b9f772e0bf4d244c27177c53f73ed24">compound_member</a> (C Parent::*c_ptr, const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga0b9f772e0bf4d244c27177c53f73ed24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta information for a non-trivial member <code>C</code>, whereas <code>args</code> are the "sub-members" of <code>c_ptr</code>.  <a href="group___type_system.html#ga0b9f772e0bf4d244c27177c53f73ed24">More...</a><br /></td></tr>
<tr class="separator:ga0b9f772e0bf4d244c27177c53f73ed24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d57a44ee77a9ee60264c7c517e69ce0"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , class... Ts&gt; </td></tr>
<tr class="memitem:ga2d57a44ee77a9ee60264c7c517e69ce0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C &amp;(Parent::*)(), <br class="typebreak" />
detail::abstract_uniform_type_info<br class="typebreak" />
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga2d57a44ee77a9ee60264c7c517e69ce0">compound_member</a> (C &amp;(Parent::*getter)(), const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga2d57a44ee77a9ee60264c7c517e69ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta information for a non-trivial member accessed via a getter returning a mutable reference, whereas <code>args</code> are the "sub-members" of <code>c_ptr</code>.  <a href="group___type_system.html#ga2d57a44ee77a9ee60264c7c517e69ce0">More...</a><br /></td></tr>
<tr class="separator:ga2d57a44ee77a9ee60264c7c517e69ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7592bf110335172f31421311116f20f0"><td class="memTemplParams" colspan="2">template&lt;class Parent , class GRes , class SRes , class SArg , class... Ts&gt; </td></tr>
<tr class="memitem:ga7592bf110335172f31421311116f20f0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; GRes(Parent::*)() <br class="typebreak" />
const, SRes(Parent::*)(SArg)&gt;<br class="typebreak" />
, detail::abstract_uniform_type_info<br class="typebreak" />
&lt; typename <br class="typebreak" />
detail::rm_const_and_ref&lt; GRes &gt;<br class="typebreak" />
::type &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga7592bf110335172f31421311116f20f0">compound_member</a> (const std::pair&lt; GRes(Parent::*)() const, SRes(Parent::*)(SArg)&gt; &amp;gspair, const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga7592bf110335172f31421311116f20f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta information for a non-trivial member accessed via a pair of getter and setter member function pointers, whereas <code>args</code> are the "sub-members" of <code>c_ptr</code>.  <a href="group___type_system.html#ga7592bf110335172f31421311116f20f0">More...</a><br /></td></tr>
<tr class="separator:ga7592bf110335172f31421311116f20f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8468d877e9addfb8bc861ec9ba188f"><td class="memTemplParams" colspan="2">template&lt;class C , class... Ts&gt; </td></tr>
<tr class="memitem:gadc8468d877e9addfb8bc861ec9ba188f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcaf_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#gadc8468d877e9addfb8bc861ec9ba188f">announce</a> (const Ts &amp;...args)</td></tr>
<tr class="memdesc:gadc8468d877e9addfb8bc861ec9ba188f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping for <code>C</code> to the type system.  <a href="group___type_system.html#gadc8468d877e9addfb8bc861ec9ba188f">More...</a><br /></td></tr>
<tr class="separator:gadc8468d877e9addfb8bc861ec9ba188f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691af399cd2d3fb0cad52327726663c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a691af399cd2d3fb0cad52327726663c2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a691af399cd2d3fb0cad52327726663c2">to_string</a> (const <a class="el" href="namespacecaf.html#a6328c86a49e5f378b7b08711879dc8e7">atom_value</a> &amp;what)</td></tr>
<tr class="memdesc:a691af399cd2d3fb0cad52327726663c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>what</code> as a string representation. <br /></td></tr>
<tr class="separator:a691af399cd2d3fb0cad52327726663c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0492f1014680a595564db4391f950486"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0492f1014680a595564db4391f950486"></a>
template&lt;size_t Size&gt; </td></tr>
<tr class="memitem:a0492f1014680a595564db4391f950486"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecaf.html#a6328c86a49e5f378b7b08711879dc8e7">atom_value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a0492f1014680a595564db4391f950486">atom</a> (char const (&amp;str)[Size])</td></tr>
<tr class="memdesc:a0492f1014680a595564db4391f950486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an atom from given string literal. <br /></td></tr>
<tr class="separator:a0492f1014680a595564db4391f950486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6fe9cd57f8c7a05d8f774de2c450fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a3c6fe9cd57f8c7a05d8f774de2c450fe">await_all_actors_done</a> ()</td></tr>
<tr class="memdesc:a3c6fe9cd57f8c7a05d8f774de2c450fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks execution of this actor until all other actors finished execution.  <a href="#a3c6fe9cd57f8c7a05d8f774de2c450fe">More...</a><br /></td></tr>
<tr class="separator:a3c6fe9cd57f8c7a05d8f774de2c450fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc74cab8e03dc37726acaa42177b702"><td class="memTemplParams" colspan="2"><a class="anchor" id="acbc74cab8e03dc37726acaa42177b702"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acbc74cab8e03dc37726acaa42177b702"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1binary__deserializer.html">binary_deserializer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classcaf_1_1binary__deserializer.html">binary_deserializer</a> &amp;lhs, T &amp;rhs)</td></tr>
<tr class="separator:acbc74cab8e03dc37726acaa42177b702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615b205bf1833c549cf754e97524621c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a615b205bf1833c549cf754e97524621c"></a>
template&lt;class T , class  = typename std::enable_if&lt;detail::is_primitive&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a615b205bf1833c549cf754e97524621c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1binary__serializer.html">binary_serializer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="classcaf_1_1binary__serializer.html">binary_serializer</a> &amp;bs, const T &amp;value)</td></tr>
<tr class="separator:a615b205bf1833c549cf754e97524621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3551966ac4432cd137a936fd80464059"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3551966ac4432cd137a936fd80464059"></a>
template&lt;class Period &gt; </td></tr>
<tr class="memitem:a3551966ac4432cd137a936fd80464059"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecaf.html#a7952a6b8fa7dd2b9e6b750b11f3e58f8">time_unit</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a3551966ac4432cd137a936fd80464059">get_time_unit_from_period</a> ()</td></tr>
<tr class="memdesc:a3551966ac4432cd137a936fd80464059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an STL time period to a <code>time_unit</code>. <br /></td></tr>
<tr class="separator:a3551966ac4432cd137a936fd80464059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31408b7c922a213fdaac2620f8a1c1e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31408b7c922a213fdaac2620f8a1c1e9"></a>
uniform_value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a31408b7c922a213fdaac2620f8a1c1e9">from_string_impl</a> (const std::string &amp;what)</td></tr>
<tr class="memdesc:a31408b7c922a213fdaac2620f8a1c1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string created by <code>to_string</code> to its original value. <br /></td></tr>
<tr class="separator:a31408b7c922a213fdaac2620f8a1c1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ede8761eb2abd6785aa1be5de21a77"><td class="memTemplParams" colspan="2"><a class="anchor" id="a92ede8761eb2abd6785aa1be5de21a77"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a92ede8761eb2abd6785aa1be5de21a77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a92ede8761eb2abd6785aa1be5de21a77">from_string</a> (const std::string &amp;what)</td></tr>
<tr class="memdesc:a92ede8761eb2abd6785aa1be5de21a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that tries to deserializes a value from <code>what</code> and converts the result to <code>T</code>. <br /></td></tr>
<tr class="separator:a92ede8761eb2abd6785aa1be5de21a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2f68934fb3bcb2fa7c6957ecbe458c"><td class="memItemLeft" align="right" valign="top">detail::match_helper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a0e2f68934fb3bcb2fa7c6957ecbe458c">match</a> (<a class="el" href="classcaf_1_1message.html">message</a> what)</td></tr>
<tr class="memdesc:a0e2f68934fb3bcb2fa7c6957ecbe458c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression.  <a href="#a0e2f68934fb3bcb2fa7c6957ecbe458c">More...</a><br /></td></tr>
<tr class="separator:a0e2f68934fb3bcb2fa7c6957ecbe458c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d80987b1288281875c7dd3f0080918"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab0d80987b1288281875c7dd3f0080918"><td class="memTemplItemLeft" align="right" valign="top">detail::match_helper&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ab0d80987b1288281875c7dd3f0080918">match</a> (T &amp;&amp;what)</td></tr>
<tr class="memdesc:ab0d80987b1288281875c7dd3f0080918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression.  <a href="#ab0d80987b1288281875c7dd3f0080918">More...</a><br /></td></tr>
<tr class="separator:ab0d80987b1288281875c7dd3f0080918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4212fbe85aef76f1bfa02cfb6fe5221c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4212fbe85aef76f1bfa02cfb6fe5221c"></a>
detail::match_helper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a4212fbe85aef76f1bfa02cfb6fe5221c">match_split</a> (const std::string &amp;str, char delim, bool keep_empties=false)</td></tr>
<tr class="memdesc:a4212fbe85aef76f1bfa02cfb6fe5221c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> using <code>delim</code> and match the resulting strings. <br /></td></tr>
<tr class="separator:a4212fbe85aef76f1bfa02cfb6fe5221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cb5b1e3a7841befe78948dc5728048"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a32cb5b1e3a7841befe78948dc5728048"><td class="memTemplItemLeft" align="right" valign="top">detail::match_each_helper<br class="typebreak" />
&lt; InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a32cb5b1e3a7841befe78948dc5728048">match_each</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a32cb5b1e3a7841befe78948dc5728048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression that matches each element in range [first, last).  <a href="#a32cb5b1e3a7841befe78948dc5728048">More...</a><br /></td></tr>
<tr class="separator:a32cb5b1e3a7841befe78948dc5728048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5eeda80845c1e008a4b565d306132b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename Projection &gt; </td></tr>
<tr class="memitem:a9d5eeda80845c1e008a4b565d306132b"><td class="memTemplItemLeft" align="right" valign="top">detail::match_each_helper<br class="typebreak" />
&lt; InputIterator, Projection &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a9d5eeda80845c1e008a4b565d306132b">match_each</a> (InputIterator first, InputIterator last, Projection proj)</td></tr>
<tr class="memdesc:a9d5eeda80845c1e008a4b565d306132b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression that matches <code>proj(i) for each element</code>i` in range [first, last).  <a href="#a9d5eeda80845c1e008a4b565d306132b">More...</a><br /></td></tr>
<tr class="separator:a9d5eeda80845c1e008a4b565d306132b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cf24157b3ef350c0ddcede1fc98777"><td class="memTemplParams" colspan="2"><a class="anchor" id="a49cf24157b3ef350c0ddcede1fc98777"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a49cf24157b3ef350c0ddcede1fc98777"><td class="memTemplItemLeft" align="right" valign="top">detail::stream_matcher&lt; T, <br class="typebreak" />
std::istream_iterator&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_stream</b> (std::istream &amp;stream)</td></tr>
<tr class="separator:a49cf24157b3ef350c0ddcede1fc98777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5419b056b262261411e7627b84b63a25"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5419b056b262261411e7627b84b63a25"></a>
template&lt;class T , typename InputIterator &gt; </td></tr>
<tr class="memitem:a5419b056b262261411e7627b84b63a25"><td class="memTemplItemLeft" align="right" valign="top">detail::stream_matcher&lt; T, <br class="typebreak" />
InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_stream</b> (InputIterator first, InputIterator last)</td></tr>
<tr class="separator:a5419b056b262261411e7627b84b63a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892dc9bf72a9bbcbe41f4940c43715cc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a892dc9bf72a9bbcbe41f4940c43715cc"></a>
template&lt;class... Lhs, class... Rhs&gt; </td></tr>
<tr class="memitem:a892dc9bf72a9bbcbe41f4940c43715cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1match__expr.html">match_expr</a>&lt; Lhs..., Rhs...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator,</b> (const <a class="el" href="classcaf_1_1match__expr.html">match_expr</a>&lt; Lhs...&gt; &amp;lhs, const <a class="el" href="classcaf_1_1match__expr.html">match_expr</a>&lt; Rhs...&gt; &amp;rhs)</td></tr>
<tr class="separator:a892dc9bf72a9bbcbe41f4940c43715cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd2108a59de3fba8a29b261cf9a1837"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3cd2108a59de3fba8a29b261cf9a1837"></a>
template&lt;class... Cs&gt; </td></tr>
<tr class="memitem:a3cd2108a59de3fba8a29b261cf9a1837"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (<a class="el" href="classcaf_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;arg)</td></tr>
<tr class="separator:a3cd2108a59de3fba8a29b261cf9a1837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bcec5c866e5aaafcfc092335d80459"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad0bcec5c866e5aaafcfc092335d80459"></a>
template&lt;class... Cs&gt; </td></tr>
<tr class="memitem:ad0bcec5c866e5aaafcfc092335d80459"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (<a class="el" href="classcaf_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&amp;arg)</td></tr>
<tr class="separator:ad0bcec5c866e5aaafcfc092335d80459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9013a74428d92b652c98d1d7a4db0f42"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9013a74428d92b652c98d1d7a4db0f42"></a>
template&lt;class... Cs&gt; </td></tr>
<tr class="memitem:a9013a74428d92b652c98d1d7a4db0f42"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcaf_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (const <a class="el" href="classcaf_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;arg)</td></tr>
<tr class="separator:a9013a74428d92b652c98d1d7a4db0f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2033457d69d823c22ec30c564bd9b4b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2033457d69d823c22ec30c564bd9b4b9"></a>
template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:a2033457d69d823c22ec30c564bd9b4b9"><td class="memTemplItemLeft" align="right" valign="top">detail::tl_apply&lt; typename <br class="typebreak" />
detail::tl_concat&lt; typename <br class="typebreak" />
T::cases_list, typename <br class="typebreak" />
Ts::cases_list...&gt;::type, <br class="typebreak" />
<a class="el" href="classcaf_1_1match__expr.html">match_expr</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (const T &amp;arg, const Ts &amp;...args)</td></tr>
<tr class="separator:a2033457d69d823c22ec30c564bd9b4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b70be2266ad1a24e5cfcccc471f7f2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a96b70be2266ad1a24e5cfcccc471f7f2"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a96b70be2266ad1a24e5cfcccc471f7f2">val</a> ()</td></tr>
<tr class="memdesc:a96b70be2266ad1a24e5cfcccc471f7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches any value of type <code>T</code>.  <a href="#a96b70be2266ad1a24e5cfcccc471f7f2">More...</a><br /></td></tr>
<tr class="separator:a96b70be2266ad1a24e5cfcccc471f7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68584d36bba7035718fcf255199e3be6"><td class="memTemplParams" colspan="2">template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:a68584d36bba7035718fcf255199e3be6"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a68584d36bba7035718fcf255199e3be6">on</a> (const T &amp;arg, const Ts &amp;...args)</td></tr>
<tr class="memdesc:a68584d36bba7035718fcf255199e3be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches values.  <a href="#a68584d36bba7035718fcf255199e3be6">More...</a><br /></td></tr>
<tr class="separator:a68584d36bba7035718fcf255199e3be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28476a95716b9793ba56ad78e04b4667"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a28476a95716b9793ba56ad78e04b4667"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a28476a95716b9793ba56ad78e04b4667">on</a> ()</td></tr>
<tr class="memdesc:a28476a95716b9793ba56ad78e04b4667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches types.  <a href="#a28476a95716b9793ba56ad78e04b4667">More...</a><br /></td></tr>
<tr class="separator:a28476a95716b9793ba56ad78e04b4667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0074742c53b931f58c5fd3afc55530"><td class="memTemplParams" colspan="2">template&lt;atom_value... Atoms, class... Ts&gt; </td></tr>
<tr class="memitem:aae0074742c53b931f58c5fd3afc55530"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#aae0074742c53b931f58c5fd3afc55530">on</a> ()</td></tr>
<tr class="memdesc:aae0074742c53b931f58c5fd3afc55530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches types.  <a href="#aae0074742c53b931f58c5fd3afc55530">More...</a><br /></td></tr>
<tr class="separator:aae0074742c53b931f58c5fd3afc55530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e723f4da101e0eaddb9e08289f20c80"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e723f4da101e0eaddb9e08289f20c80"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8e723f4da101e0eaddb9e08289f20c80"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a8e723f4da101e0eaddb9e08289f20c80">lift_to_match_expr</a> (T arg)</td></tr>
<tr class="memdesc:a8e723f4da101e0eaddb9e08289f20c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>arg</code> to a match expression by returning <code>on_arg_match &gt;&gt; arg if</code>arg<code>is a callable type, otherwise returns</code>arg`. <br /></td></tr>
<tr class="separator:a8e723f4da101e0eaddb9e08289f20c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7276a89e1f028dee65c8720b1da2f440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a7276a89e1f028dee65c8720b1da2f440">set_scheduler</a> (<a class="el" href="classcaf_1_1scheduler_1_1abstract__coordinator.html">scheduler::abstract_coordinator</a> *ptr)</td></tr>
<tr class="memdesc:a7276a89e1f028dee65c8720b1da2f440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user-defined scheduler.  <a href="#a7276a89e1f028dee65c8720b1da2f440">More...</a><br /></td></tr>
<tr class="separator:a7276a89e1f028dee65c8720b1da2f440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba6d194f5742a3d5d2cb09bb4d3d1a5"><td class="memTemplParams" colspan="2">template&lt;class StealPolicy , class JobQueuePolicy &gt; </td></tr>
<tr class="memitem:a7ba6d194f5742a3d5d2cb09bb4d3d1a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a7ba6d194f5742a3d5d2cb09bb4d3d1a5">set_scheduler</a> (size_t nw=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:a7ba6d194f5742a3d5d2cb09bb4d3d1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user-defined scheduler using given policies.  <a href="#a7ba6d194f5742a3d5d2cb09bb4d3d1a5">More...</a><br /></td></tr>
<tr class="separator:a7ba6d194f5742a3d5d2cb09bb4d3d1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46732d4d6280d292823ab90cf1787047"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46732d4d6280d292823ab90cf1787047"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a46732d4d6280d292823ab90cf1787047">send_tuple_as</a> (const <a class="el" href="classcaf_1_1actor.html">actor</a> &amp;from, const <a class="el" href="classcaf_1_1channel.html">channel</a> &amp;to, <a class="el" href="classcaf_1_1message.html">message</a> msg)</td></tr>
<tr class="memdesc:a46732d4d6280d292823ab90cf1787047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>to</code> a message under the identity of <code>from</code>. <br /></td></tr>
<tr class="separator:a46732d4d6280d292823ab90cf1787047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e95edc7f388b9e0ea590155f04d106"><td class="memTemplParams" colspan="2"><a class="anchor" id="af5e95edc7f388b9e0ea590155f04d106"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:af5e95edc7f388b9e0ea590155f04d106"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#af5e95edc7f388b9e0ea590155f04d106">send_as</a> (const <a class="el" href="classcaf_1_1actor.html">actor</a> &amp;from, const <a class="el" href="classcaf_1_1channel.html">channel</a> &amp;to, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:af5e95edc7f388b9e0ea590155f04d106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>to</code> a message under the identity of <code>from</code>. <br /></td></tr>
<tr class="separator:af5e95edc7f388b9e0ea590155f04d106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7f11e5db6f1933328b31321f302424"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f7f11e5db6f1933328b31321f302424"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a3f7f11e5db6f1933328b31321f302424">anon_send_tuple</a> (const <a class="el" href="classcaf_1_1channel.html">channel</a> &amp;to, <a class="el" href="classcaf_1_1message.html">message</a> msg)</td></tr>
<tr class="memdesc:a3f7f11e5db6f1933328b31321f302424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>to</code> a message. <br /></td></tr>
<tr class="separator:a3f7f11e5db6f1933328b31321f302424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce3fba36841807003c28ac828e8a4e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ce3fba36841807003c28ac828e8a4e4"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a2ce3fba36841807003c28ac828e8a4e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a2ce3fba36841807003c28ac828e8a4e4">anon_send</a> (const <a class="el" href="classcaf_1_1channel.html">channel</a> &amp;to, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a2ce3fba36841807003c28ac828e8a4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>to</code> a message. <br /></td></tr>
<tr class="separator:a2ce3fba36841807003c28ac828e8a4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0681a99aaa374f2a9941def44fd3519d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0681a99aaa374f2a9941def44fd3519d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a0681a99aaa374f2a9941def44fd3519d">anon_send_exit</a> (const <a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a> &amp;whom, uint32_t reason)</td></tr>
<tr class="memdesc:a0681a99aaa374f2a9941def44fd3519d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>whom</code> an exit message. <br /></td></tr>
<tr class="separator:a0681a99aaa374f2a9941def44fd3519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea12409207164d97bc1ed18b8f5ba02d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea12409207164d97bc1ed18b8f5ba02d"></a>
template&lt;class ActorHandle &gt; </td></tr>
<tr class="memitem:aea12409207164d97bc1ed18b8f5ba02d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#aea12409207164d97bc1ed18b8f5ba02d">anon_send_exit</a> (const ActorHandle &amp;whom, uint32_t reason)</td></tr>
<tr class="memdesc:aea12409207164d97bc1ed18b8f5ba02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>whom</code> an exit message. <br /></td></tr>
<tr class="separator:aea12409207164d97bc1ed18b8f5ba02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81ec892720a081de187e74fe1b3b2d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ae81ec892720a081de187e74fe1b3b2d0">shutdown</a> ()</td></tr>
<tr class="memdesc:ae81ec892720a081de187e74fe1b3b2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all singletons and stops the scheduler.  <a href="#ae81ec892720a081de187e74fe1b3b2d0">More...</a><br /></td></tr>
<tr class="separator:ae81ec892720a081de187e74fe1b3b2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3a2d703f54a6088979993237b04a37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf3a2d703f54a6088979993237b04a37"></a>
constexpr <a class="el" href="structcaf_1_1skip__message__t.html">skip_message_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#aaf3a2d703f54a6088979993237b04a37">skip_message</a> ()</td></tr>
<tr class="memdesc:aaf3a2d703f54a6088979993237b04a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the runtime system to skip a message when used as message handler, i.e., causes the runtime to leave the message in the mailbox of an actor. <br /></td></tr>
<tr class="separator:aaf3a2d703f54a6088979993237b04a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc48d906f58be1ada9b48ab8bb60fab2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc48d906f58be1ada9b48ab8bb60fab2"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, <a class="el" href="structcaf_1_1skip__message__t.html">skip_message_t</a>)</td></tr>
<tr class="separator:afc48d906f58be1ada9b48ab8bb60fab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8be7640442e7994c2d74a3eb614720"><td class="memTemplParams" colspan="2">template&lt;class C , spawn_options Os, class BeforeLaunch , class... Ts&gt; </td></tr>
<tr class="memitem:a7d8be7640442e7994c2d74a3eb614720"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a7d8be7640442e7994c2d74a3eb614720">spawn_impl</a> (<a class="el" href="classcaf_1_1execution__unit.html">execution_unit</a> *host, BeforeLaunch before_launch_fun, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7d8be7640442e7994c2d74a3eb614720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly spawned instance of type <code>C</code> using <code>args...</code> as constructor arguments.  <a href="#a7d8be7640442e7994c2d74a3eb614720">More...</a><br /></td></tr>
<tr class="separator:a7d8be7640442e7994c2d74a3eb614720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca36d333c3ff18e3718867a171942e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaca36d333c3ff18e3718867a171942e7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aaca36d333c3ff18e3718867a171942e7"><td class="memTemplItemLeft" align="right" valign="top">std::conditional<br class="typebreak" />
&lt; is_convertible_to_actor<br class="typebreak" />
&lt; typename <br class="typebreak" />
detail::rm_const_and_ref&lt; T &gt;<br class="typebreak" />
::type &gt;::value, <a class="el" href="classcaf_1_1actor.html">actor</a>, T &amp;&amp; &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#aaca36d333c3ff18e3718867a171942e7">spawn_fwd</a> (typename std::remove_reference&lt; T &gt;::type &amp;arg) noexcept</td></tr>
<tr class="memdesc:aaca36d333c3ff18e3718867a171942e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code><a class="el" href="classcaf_1_1scoped__actor.html" title="A scoped handle to a blocking actor. ">scoped_actor</a></code> and pointers to actors to handles of type <code>actor</code> but simply forwards any other argument in the same way <code>std::forward</code> does. <br /></td></tr>
<tr class="separator:aaca36d333c3ff18e3718867a171942e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af06594d20cbb77a29ae565aae59222"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6af06594d20cbb77a29ae565aae59222"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6af06594d20cbb77a29ae565aae59222"><td class="memTemplItemLeft" align="right" valign="top">std::conditional<br class="typebreak" />
&lt; is_convertible_to_actor<br class="typebreak" />
&lt; typename <br class="typebreak" />
detail::rm_const_and_ref&lt; T &gt;<br class="typebreak" />
::type &gt;::value, <a class="el" href="classcaf_1_1actor.html">actor</a>, T &amp;&amp; &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a6af06594d20cbb77a29ae565aae59222">spawn_fwd</a> (typename std::remove_reference&lt; T &gt;::type &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a6af06594d20cbb77a29ae565aae59222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code><a class="el" href="classcaf_1_1scoped__actor.html" title="A scoped handle to a blocking actor. ">scoped_actor</a></code> and pointers to actors to handles of type <code>actor</code> but simply forwards any other argument in the same way <code>std::forward</code> does. <br /></td></tr>
<tr class="separator:a6af06594d20cbb77a29ae565aae59222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a083e814f57c85c6810496b4360781"><td class="memTemplParams" colspan="2">template&lt;class C , spawn_options Os, typename BeforeLaunch , class... Ts&gt; </td></tr>
<tr class="memitem:a03a083e814f57c85c6810496b4360781"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a03a083e814f57c85c6810496b4360781">spawn_class</a> (<a class="el" href="classcaf_1_1execution__unit.html">execution_unit</a> *host, BeforeLaunch before_launch_fun, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a03a083e814f57c85c6810496b4360781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <code>spawn</code> when used to create a class-based actor (usually should not be called by users of the library).  <a href="#a03a083e814f57c85c6810496b4360781">More...</a><br /></td></tr>
<tr class="separator:a03a083e814f57c85c6810496b4360781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440bd9d2effba7d4903e049b56d25e7c"><td class="memTemplParams" colspan="2">template&lt;spawn_options Os, typename BeforeLaunch , typename F , class... Ts&gt; </td></tr>
<tr class="memitem:a440bd9d2effba7d4903e049b56d25e7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a440bd9d2effba7d4903e049b56d25e7c">spawn_functor</a> (<a class="el" href="classcaf_1_1execution__unit.html">execution_unit</a> *eu, BeforeLaunch cb, F fun, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a440bd9d2effba7d4903e049b56d25e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <code>spawn</code> when used to create a functor-based actor (usually should not be called by users of the library).  <a href="#a440bd9d2effba7d4903e049b56d25e7c">More...</a><br /></td></tr>
<tr class="separator:a440bd9d2effba7d4903e049b56d25e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b7dca8b81184f61cf262f14d8e748a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96b7dca8b81184f61cf262f14d8e748a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>is_any_of</b> (std::string arg)</td></tr>
<tr class="separator:a96b7dca8b81184f61cf262f14d8e748a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9318a878a630fee5963dca1e7bde7546"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9318a878a630fee5963dca1e7bde7546"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> (std::vector&lt; std::string &gt; &amp;result, const std::string &amp;str, const std::string &amp;delimiters=&quot; &quot;, bool keep_empties=true)</td></tr>
<tr class="separator:a9318a878a630fee5963dca1e7bde7546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a49e225ea18fbfd95d785f5071b13a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2a49e225ea18fbfd95d785f5071b13a"></a>
template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:ac2a49e225ea18fbfd95d785f5071b13a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>join</b> (Iterator begin, Iterator end, const std::string &amp;glue)</td></tr>
<tr class="separator:ac2a49e225ea18fbfd95d785f5071b13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34966b1293175d34b44ff801eea642b"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa34966b1293175d34b44ff801eea642b"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:aa34966b1293175d34b44ff801eea642b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>join</b> (const Container &amp;c, const std::string &amp;glue)</td></tr>
<tr class="separator:aa34966b1293175d34b44ff801eea642b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1197c63f96f6aea1d224f55b6ed935fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1197c63f96f6aea1d224f55b6ed935fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>splice</b> (std::string &amp;, const std::string &amp;)</td></tr>
<tr class="separator:a1197c63f96f6aea1d224f55b6ed935fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871da856b175da62f395e3351c2ed52e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a871da856b175da62f395e3351c2ed52e"></a>
template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:a871da856b175da62f395e3351c2ed52e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>splice</b> (std::string &amp;str, const std::string &amp;glue, T &amp;&amp;arg, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:a871da856b175da62f395e3351c2ed52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a35200e5634e8e3cef451815153c85"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89a35200e5634e8e3cef451815153c85"></a>
template&lt;size_t WhatSize, size_t WithSize&gt; </td></tr>
<tr class="memitem:a89a35200e5634e8e3cef451815153c85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>replace_all</b> (std::string &amp;str, const char(&amp;what)[WhatSize], const char(&amp;with)[WithSize])</td></tr>
<tr class="separator:a89a35200e5634e8e3cef451815153c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332f2f76b10fb04fd11f5f5b5648a508"><td class="memTemplParams" colspan="2">template&lt;class T , typename U &gt; </td></tr>
<tr class="memitem:a332f2f76b10fb04fd11f5f5b5648a508"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; !std::is_floating_point&lt; T &gt;<br class="typebreak" />
::value <br class="typebreak" />
&amp;&amp;!std::is_floating_point&lt; U &gt;<br class="typebreak" />
::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a332f2f76b10fb04fd11f5f5b5648a508">safe_equal</a> (const T &amp;lhs, const U &amp;rhs)</td></tr>
<tr class="memdesc:a332f2f76b10fb04fd11f5f5b5648a508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values by using <code>operator==</code> unless two floating point numbers are compared.  <a href="#a332f2f76b10fb04fd11f5f5b5648a508">More...</a><br /></td></tr>
<tr class="separator:a332f2f76b10fb04fd11f5f5b5648a508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb0a071b8c9c5f4dc483c32c9c82079"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4eb0a071b8c9c5f4dc483c32c9c82079"></a>
template&lt;class T , typename U &gt; </td></tr>
<tr class="memitem:a4eb0a071b8c9c5f4dc483c32c9c82079"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; std::is_floating_point&lt; T &gt;<br class="typebreak" />
::value||std::is_floating_point<br class="typebreak" />
&lt; U &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>safe_equal</b> (const T &amp;lhs, const U &amp;rhs)</td></tr>
<tr class="separator:a4eb0a071b8c9c5f4dc483c32c9c82079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e86b06e4e5b362aecb2536015a9d761"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e86b06e4e5b362aecb2536015a9d761"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1e86b06e4e5b362aecb2536015a9d761"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; detail::tl_exists<br class="typebreak" />
&lt; detail::type_list&lt; <a class="el" href="structcaf_1_1exit__msg.html">exit_msg</a>, <br class="typebreak" />
<a class="el" href="structcaf_1_1down__msg.html">down_msg</a>, <a class="el" href="structcaf_1_1sync__exited__msg.html">sync_exited_msg</a> &gt;<br class="typebreak" />
, detail::tbind&lt; std::is_same, <br class="typebreak" />
T &gt;::template type &gt;::value, <br class="typebreak" />
bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a1e86b06e4e5b362aecb2536015a9d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52cec99028a5108aec74c920c11e665"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae52cec99028a5108aec74c920c11e665"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae52cec99028a5108aec74c920c11e665"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; detail::tl_exists<br class="typebreak" />
&lt; detail::type_list&lt; <a class="el" href="structcaf_1_1exit__msg.html">exit_msg</a>, <br class="typebreak" />
<a class="el" href="structcaf_1_1down__msg.html">down_msg</a>, <a class="el" href="structcaf_1_1sync__exited__msg.html">sync_exited_msg</a> &gt;<br class="typebreak" />
, detail::tbind&lt; std::is_same, <br class="typebreak" />
T &gt;::template type &gt;::value, <br class="typebreak" />
bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:ae52cec99028a5108aec74c920c11e665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d88695c6fc6b2ccc54e09241f5e4efb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d88695c6fc6b2ccc54e09241f5e4efb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structcaf_1_1group__down__msg.html">group_down_msg</a> &amp;lhs, const <a class="el" href="structcaf_1_1group__down__msg.html">group_down_msg</a> &amp;rhs)</td></tr>
<tr class="separator:a4d88695c6fc6b2ccc54e09241f5e4efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d7b575116311282eb2110b509829af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9d7b575116311282eb2110b509829af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structcaf_1_1group__down__msg.html">group_down_msg</a> &amp;lhs, const <a class="el" href="structcaf_1_1group__down__msg.html">group_down_msg</a> &amp;rhs)</td></tr>
<tr class="separator:aa9d7b575116311282eb2110b509829af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0569059bdc261b153a0a154f04190180"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0569059bdc261b153a0a154f04190180"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structcaf_1_1timeout__msg.html">timeout_msg</a> &amp;lhs, const <a class="el" href="structcaf_1_1timeout__msg.html">timeout_msg</a> &amp;rhs)</td></tr>
<tr class="separator:a0569059bdc261b153a0a154f04190180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0272199ae7b76633f00f03c62e0a313"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0272199ae7b76633f00f03c62e0a313"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structcaf_1_1timeout__msg.html">timeout_msg</a> &amp;lhs, const <a class="el" href="structcaf_1_1timeout__msg.html">timeout_msg</a> &amp;rhs)</td></tr>
<tr class="separator:af0272199ae7b76633f00f03c62e0a313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11f999b2d3a332e184d8b51671b91c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af11f999b2d3a332e184d8b51671b91c4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1message.html">message</a> &amp;what)</td></tr>
<tr class="separator:af11f999b2d3a332e184d8b51671b91c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66fe1d63e7a39ccd025760571443278"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad66fe1d63e7a39ccd025760571443278"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1actor.html">actor</a> &amp;what)</td></tr>
<tr class="separator:ad66fe1d63e7a39ccd025760571443278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78963ff977713eb90a596c2a6970052c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78963ff977713eb90a596c2a6970052c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a> &amp;what)</td></tr>
<tr class="separator:a78963ff977713eb90a596c2a6970052c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab80ab3e130f27526c5950ca47d51d12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab80ab3e130f27526c5950ca47d51d12"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const group &amp;what)</td></tr>
<tr class="separator:aab80ab3e130f27526c5950ca47d51d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c0072b5935847d6e9655eb774fd0a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3c0072b5935847d6e9655eb774fd0a4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1channel.html">channel</a> &amp;what)</td></tr>
<tr class="separator:aa3c0072b5935847d6e9655eb774fd0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05b1f8882a9a540a3e472f25b340154"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af05b1f8882a9a540a3e472f25b340154"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1node__id.html">node_id</a> &amp;what)</td></tr>
<tr class="separator:af05b1f8882a9a540a3e472f25b340154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bda449243824a6a8d16710d06e5aec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67bda449243824a6a8d16710d06e5aec"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a67bda449243824a6a8d16710d06e5aec">to_verbose_string</a> (const std::exception &amp;e)</td></tr>
<tr class="memdesc:a67bda449243824a6a8d16710d06e5aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>e</code> to a string including the demangled type of <code>e</code> and <code>e.what()</code>. <br /></td></tr>
<tr class="separator:a67bda449243824a6a8d16710d06e5aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13795104f0610fcb7521990c6ac9be08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13795104f0610fcb7521990c6ac9be08"></a>
const <a class="el" href="classcaf_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>uniform_typeid</b> (const std::type_info &amp;)</td></tr>
<tr class="separator:a13795104f0610fcb7521990c6ac9be08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce92582c05dac57cbee6d2f1161f269"><td class="memTemplParams" colspan="2"><a class="anchor" id="abce92582c05dac57cbee6d2f1161f269"></a>
template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:abce92582c05dac57cbee6d2f1161f269"><td class="memTemplItemLeft" align="right" valign="top">uniform_value&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_uniform_value</b> (const <a class="el" href="classcaf_1_1uniform__type__info.html">uniform_type_info</a> *ti, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:abce92582c05dac57cbee6d2f1161f269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e7033786815a77a68e3a877852147a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55e7033786815a77a68e3a877852147a"></a>
template&lt;class Types &gt; </td></tr>
<tr class="memitem:a55e7033786815a77a68e3a877852147a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecaf.html#a3ee60fa2e31e2403d555e38db286eb40">wildcard_position</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a55e7033786815a77a68e3a877852147a">get_wildcard_position</a> ()</td></tr>
<tr class="memdesc:a55e7033786815a77a68e3a877852147a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of <code>anything</code> from the type list <code>Types</code>. <br /></td></tr>
<tr class="separator:a55e7033786815a77a68e3a877852147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gadf1d60e6ce94df89f9b589bb61198aaf"><td class="memTemplParams" colspan="2">template&lt;class C , spawn_options Os = no_spawn_options, class... Ts&gt; </td></tr>
<tr class="memitem:gadf1d60e6ce94df89f9b589bb61198aaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gadf1d60e6ce94df89f9b589bb61198aaf">spawn</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gadf1d60e6ce94df89f9b589bb61198aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new actor of type <code>C</code> using <code>args...</code> as constructor arguments.  <a href="group___actor_creation.html#gadf1d60e6ce94df89f9b589bb61198aaf">More...</a><br /></td></tr>
<tr class="separator:gadf1d60e6ce94df89f9b589bb61198aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b61ffc391a27a4d249e1078ff3ddd56"><td class="memTemplParams" colspan="2">template&lt;spawn_options Os = no_spawn_options, class... Ts&gt; </td></tr>
<tr class="memitem:ga1b61ffc391a27a4d249e1078ff3ddd56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga1b61ffc391a27a4d249e1078ff3ddd56">spawn</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga1b61ffc391a27a4d249e1078ff3ddd56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new functor-based actor.  <a href="group___actor_creation.html#ga1b61ffc391a27a4d249e1078ff3ddd56">More...</a><br /></td></tr>
<tr class="separator:ga1b61ffc391a27a4d249e1078ff3ddd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c575880b788515e13b6c35cb39b5f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga71c575880b788515e13b6c35cb39b5f1"></a>
template&lt;class C , spawn_options Os = no_spawn_options, class... Ts&gt; </td></tr>
<tr class="memitem:ga71c575880b788515e13b6c35cb39b5f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga71c575880b788515e13b6c35cb39b5f1">spawn_in_group</a> (const group &amp;grp, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga71c575880b788515e13b6c35cb39b5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new actor that immediately, i.e., before this function returns, joins <code>grp</code> of type <code>C</code> using <code>args</code> as constructor arguments. <br /></td></tr>
<tr class="separator:ga71c575880b788515e13b6c35cb39b5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5455a97a79233fad0592ea7caa0e4a03"><td class="memTemplParams" colspan="2">template&lt;spawn_options Os = no_spawn_options, class... Ts&gt; </td></tr>
<tr class="memitem:ga5455a97a79233fad0592ea7caa0e4a03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga5455a97a79233fad0592ea7caa0e4a03">spawn_in_group</a> (const group &amp;grp, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga5455a97a79233fad0592ea7caa0e4a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new actor that immediately, i.e., before this function returns, joins <code>grp</code>.  <a href="group___actor_creation.html#ga5455a97a79233fad0592ea7caa0e4a03">More...</a><br /></td></tr>
<tr class="separator:ga5455a97a79233fad0592ea7caa0e4a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab89e359c4f10d1f4345e3aea5397018d"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab89e359c4f10d1f4345e3aea5397018d"></a>
template&lt;class C , spawn_options Os = no_spawn_options, class... Ts&gt; </td></tr>
<tr class="memitem:gab89e359c4f10d1f4345e3aea5397018d"><td class="memTemplItemLeft" align="right" valign="top">actor_handle_from_signature_list<br class="typebreak" />
&lt; typename C::signatures &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gab89e359c4f10d1f4345e3aea5397018d">spawn_typed</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gab89e359c4f10d1f4345e3aea5397018d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new typed actor of type <code>C</code> using <code>args...</code> as constructor arguments. <br /></td></tr>
<tr class="separator:gab89e359c4f10d1f4345e3aea5397018d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae197ade2ab9525b04f0b3d7df6e473a"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaae197ade2ab9525b04f0b3d7df6e473a"></a>
template&lt;spawn_options Os, typename BeforeLaunch , typename F , class... Ts&gt; </td></tr>
<tr class="memitem:gaae197ade2ab9525b04f0b3d7df6e473a"><td class="memTemplItemLeft" align="right" valign="top">infer_typed_actor_handle<br class="typebreak" />
&lt; typename <br class="typebreak" />
detail::get_callable_trait&lt; F &gt;<br class="typebreak" />
::result_type, typename <br class="typebreak" />
detail::tl_head&lt; typename <br class="typebreak" />
detail::get_callable_trait&lt; F &gt;<br class="typebreak" />
::arg_types &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gaae197ade2ab9525b04f0b3d7df6e473a">spawn_typed_functor</a> (<a class="el" href="classcaf_1_1execution__unit.html">execution_unit</a> *eu, BeforeLaunch bl, F fun, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gaae197ade2ab9525b04f0b3d7df6e473a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a typed actor from a functor . <br /></td></tr>
<tr class="separator:gaae197ade2ab9525b04f0b3d7df6e473a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb126a1bdd45e5740750492fb4aecbe0"><td class="memTemplParams" colspan="2">template&lt;spawn_options Os = no_spawn_options, typename F , class... Ts&gt; </td></tr>
<tr class="memitem:gaeb126a1bdd45e5740750492fb4aecbe0"><td class="memTemplItemLeft" align="right" valign="top">infer_typed_actor_handle<br class="typebreak" />
&lt; typename <br class="typebreak" />
detail::get_callable_trait&lt; F &gt;<br class="typebreak" />
::result_type, typename <br class="typebreak" />
detail::tl_head&lt; typename <br class="typebreak" />
detail::get_callable_trait&lt; F &gt;<br class="typebreak" />
::arg_types &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gaeb126a1bdd45e5740750492fb4aecbe0">spawn_typed</a> (F fun, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gaeb126a1bdd45e5740750492fb4aecbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new typed actor from a functor.  <a href="group___actor_creation.html#gaeb126a1bdd45e5740750492fb4aecbe0">More...</a><br /></td></tr>
<tr class="separator:gaeb126a1bdd45e5740750492fb4aecbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a634bae6bff966f7fc1f7943267d4c03c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a634bae6bff966f7fc1f7943267d4c03c"></a>
constexpr actor_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a634bae6bff966f7fc1f7943267d4c03c">invalid_actor_id</a> = 0</td></tr>
<tr class="memdesc:a634bae6bff966f7fc1f7943267d4c03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes an ID that is never used by an actor. <br /></td></tr>
<tr class="separator:a634bae6bff966f7fc1f7943267d4c03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d88e174972c62830f90aa1e47dda3ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d88e174972c62830f90aa1e47dda3ed"></a>
static constexpr none_t&#160;</td><td class="memItemRight" valign="bottom"><b>none</b> = none_t{}</td></tr>
<tr class="separator:a1d88e174972c62830f90aa1e47dda3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a656ac265aaa72f8fc5d8488dd7a7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93a656ac265aaa72f8fc5d8488dd7a7d"></a>
constexpr <a class="el" href="structcaf_1_1anything.html">anything</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a93a656ac265aaa72f8fc5d8488dd7a7d">any_vals</a> = <a class="el" href="structcaf_1_1anything.html">anything</a>{}</td></tr>
<tr class="memdesc:a93a656ac265aaa72f8fc5d8488dd7a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches any number of any values. <br /></td></tr>
<tr class="separator:a93a656ac265aaa72f8fc5d8488dd7a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07320f4a961c5791979c4b44a73b50f"><td class="memItemLeft" align="right" valign="top">constexpr __unspecified__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#aa07320f4a961c5791979c4b44a73b50f">arg_match</a></td></tr>
<tr class="memdesc:aa07320f4a961c5791979c4b44a73b50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches the argument types of a given callback.  <a href="#aa07320f4a961c5791979c4b44a73b50f">More...</a><br /></td></tr>
<tr class="separator:aa07320f4a961c5791979c4b44a73b50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e60be904990d765d5f7744a2c70a8f"><td class="memItemLeft" align="right" valign="top">constexpr __unspecified__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a96e60be904990d765d5f7744a2c70a8f">on_arg_match</a></td></tr>
<tr class="memdesc:a96e60be904990d765d5f7744a2c70a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression.  <a href="#a96e60be904990d765d5f7744a2c70a8f">More...</a><br /></td></tr>
<tr class="separator:a96e60be904990d765d5f7744a2c70a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7c553cccbcd493d4e7311b46cfb05e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f7c553cccbcd493d4e7311b46cfb05e"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>token_compress_on</b> = false</td></tr>
<tr class="separator:a3f7c553cccbcd493d4e7311b46cfb05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c13c88cc2dbdf94635f48198ff325b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23c13c88cc2dbdf94635f48198ff325b"></a>
static constexpr unit_t&#160;</td><td class="memItemRight" valign="bottom"><b>unit</b> = unit_t{}</td></tr>
<tr class="separator:a23c13c88cc2dbdf94635f48198ff325b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abbb9f9de56a173754932f0c6473925ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbb9f9de56a173754932f0c6473925ed"></a>
constexpr <a class="el" href="classcaf_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#abbb9f9de56a173754932f0c6473925ed">no_spawn_options</a> = spawn_options::no_flags</td></tr>
<tr class="memdesc:abbb9f9de56a173754932f0c6473925ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes default settings. <br /></td></tr>
<tr class="separator:abbb9f9de56a173754932f0c6473925ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197ff1f076793001295b672ab23790a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a197ff1f076793001295b672ab23790a2"></a>
constexpr <a class="el" href="classcaf_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a197ff1f076793001295b672ab23790a2">monitored</a> = spawn_options::monitor_flag</td></tr>
<tr class="memdesc:a197ff1f076793001295b672ab23790a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call `self-&gt;monitor(...) immediately after the new actor was spawned. <br /></td></tr>
<tr class="separator:a197ff1f076793001295b672ab23790a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2e380b48f98c44b7311bd0725456d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c2e380b48f98c44b7311bd0725456d5"></a>
constexpr <a class="el" href="classcaf_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a6c2e380b48f98c44b7311bd0725456d5">linked</a> = spawn_options::link_flag</td></tr>
<tr class="memdesc:a6c2e380b48f98c44b7311bd0725456d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call `self-&gt;link_to(...) immediately after the new actor was spawned. <br /></td></tr>
<tr class="separator:a6c2e380b48f98c44b7311bd0725456d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2555e866af2cb032aabd9a506ac191bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2555e866af2cb032aabd9a506ac191bd"></a>
constexpr <a class="el" href="classcaf_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a2555e866af2cb032aabd9a506ac191bd">detached</a> = spawn_options::detach_flag</td></tr>
<tr class="memdesc:a2555e866af2cb032aabd9a506ac191bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to opt out of the cooperative scheduling. <br /></td></tr>
<tr class="separator:a2555e866af2cb032aabd9a506ac191bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b5c96cbf488921f9871ff46b0ea877"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7b5c96cbf488921f9871ff46b0ea877"></a>
constexpr <a class="el" href="classcaf_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ac7b5c96cbf488921f9871ff46b0ea877">hidden</a> = spawn_options::hide_flag</td></tr>
<tr class="memdesc:ac7b5c96cbf488921f9871ff46b0ea877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the runtime to ignore the new actor in <code><a class="el" href="namespacecaf.html#a3c6fe9cd57f8c7a05d8f774de2c450fe" title="Blocks execution of this actor until all other actors finished execution. ">await_all_actors_done()</a></code>. <br /></td></tr>
<tr class="separator:ac7b5c96cbf488921f9871ff46b0ea877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f463c87dffd381ef74f0fd0ae810e60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f463c87dffd381ef74f0fd0ae810e60"></a>
constexpr <a class="el" href="classcaf_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a2f463c87dffd381ef74f0fd0ae810e60">blocking_api</a> = spawn_options::blocking_api_flag</td></tr>
<tr class="memdesc:a2f463c87dffd381ef74f0fd0ae810e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to opt in to the blocking API, i.e., the actor uses a context-switching or thread-based backend instead of the default event-based implementation. <br /></td></tr>
<tr class="separator:a2f463c87dffd381ef74f0fd0ae810e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6018a4e383cbbd501ffa7d520a5a6dfe"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classcaf_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a6018a4e383cbbd501ffa7d520a5a6dfe">priority_aware</a> = spawn_options::priority_aware_flag</td></tr>
<tr class="memdesc:a6018a4e383cbbd501ffa7d520a5a6dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to evaluate message priorities.  <a href="#a6018a4e383cbbd501ffa7d520a5a6dfe">More...</a><br /></td></tr>
<tr class="separator:a6018a4e383cbbd501ffa7d520a5a6dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Root namespace of libcaf. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3c6fe9cd57f8c7a05d8f774de2c450fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caf::await_all_actors_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks execution of this actor until all other actors finished execution. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will cause a deadlock if called from multiple actors. </dd>
<dd>
Do not call this function in cooperatively scheduled actors. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_1_8cpp-example.html#a7">announce_1.cpp</a>, <a class="el" href="announce_2_8cpp-example.html#a4">announce_2.cpp</a>, <a class="el" href="announce_3_8cpp-example.html#a5">announce_3.cpp</a>, <a class="el" href="announce_4_8cpp-example.html#a7">announce_4.cpp</a>, <a class="el" href="announce_5_8cpp-example.html#a13">announce_5.cpp</a>, and <a class="el" href="dancing_kirby_8cpp-example.html#a5">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0e2f68934fb3bcb2fa7c6957ecbe458c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::match_helper caf::match </td>
          <td>(</td>
          <td class="paramtype">message&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Tuple that should be matched against a pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing `operator(...). </dd></dl>

</div>
</div>
<a class="anchor" id="ab0d80987b1288281875c7dd3f0080918"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_helper caf::match </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Value that should be matched against a pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing `operator(...). </dd></dl>

</div>
</div>
<a class="anchor" id="a32cb5b1e3a7841befe78948dc5728048"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_each_helper&lt;InputIterator&gt; caf::match_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression that matches each element in range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element (excluded). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing `operator(...). </dd></dl>

</div>
</div>
<a class="anchor" id="a9d5eeda80845c1e008a4b565d306132b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , typename Projection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_each_helper&lt;InputIterator, Projection&gt; caf::match_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Projection&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression that matches <code>proj(i) for each element</code>i` in range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element (excluded). </td></tr>
    <tr><td class="paramname">proj</td><td>Projection or extractor functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing `operator(...). </dd></dl>

</div>
</div>
<a class="anchor" id="a68584d36bba7035718fcf255199e3be6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ caf::on </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches values. </p>
<p>This overload can be used with the wildcards <a class="el" href="namespacecaf.html#a96b70be2266ad1a24e5cfcccc471f7f2">val</a>, <a class="el" href="namespacecaf.html#a93a656ac265aaa72f8fc5d8488dd7a7d">any_vals</a> and <a class="el" href="namespacecaf.html#aa07320f4a961c5791979c4b44a73b50f">arg_match</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a2">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a28476a95716b9793ba56ad78e04b4667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ caf::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches types. </p>
<p>This overload matches types only. The type <a class="el" href="structcaf_1_1anything.html">anything</a> can be used as wildcard to match any number of elements of any types. </p>

</div>
</div>
<a class="anchor" id="aae0074742c53b931f58c5fd3afc55530"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atom_value... Atoms, class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ caf::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches types. </p>
<p>This overload matches up to four leading atoms. The type <a class="el" href="structcaf_1_1anything.html">anything</a> can be used as wildcard to match any number of elements of any types. </p>

</div>
</div>
<a class="anchor" id="a332f2f76b10fb04fd11f5f5b5648a508"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_floating_point&lt;U&gt;::value, bool&gt;::type caf::safe_equal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two values by using <code>operator==</code> unless two floating point numbers are compared. </p>
<p>In the latter case, the function performs an epsilon comparison. </p>

</div>
</div>
<a class="anchor" id="a7276a89e1f028dee65c8720b1da2f440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caf::set_scheduler </td>
          <td>(</td>
          <td class="paramtype">scheduler::abstract_coordinator *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a user-defined scheduler. </p>
<dl class="section note"><dt>Note</dt><dd>This function must be used before actor is spawned. Dynamically changing the scheduler at runtime is not supported. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a scheduler is already defined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ba6d194f5742a3d5d2cb09bb4d3d1a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StealPolicy , class JobQueuePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void caf::set_scheduler </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nw</em> = <code>std::thread::hardware_concurrency()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a user-defined scheduler using given policies. </p>
<p>The scheduler is instantiated with <code>nw</code> number of workers. </p><dl class="section note"><dt>Note</dt><dd>This function must be used before actor is spawned. Dynamically changing the scheduler at runtime is not supported. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a scheduler is already defined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae81ec892720a081de187e74fe1b3b2d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caf::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys all singletons and stops the scheduler. </p>
<p>It is recommended to use this function as very last function call before leaving main(). </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_1_8cpp-example.html#a8">announce_1.cpp</a>, <a class="el" href="announce_2_8cpp-example.html#a5">announce_2.cpp</a>, <a class="el" href="announce_3_8cpp-example.html#a6">announce_3.cpp</a>, <a class="el" href="announce_4_8cpp-example.html#a8">announce_4.cpp</a>, <a class="el" href="announce_5_8cpp-example.html#a14">announce_5.cpp</a>, and <a class="el" href="dancing_kirby_8cpp-example.html#a6">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a03a083e814f57c85c6810496b4360781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , spawn_options Os, typename BeforeLaunch , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt; caf::spawn_class </td>
          <td>(</td>
          <td class="paramtype">execution_unit *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeforeLaunch&#160;</td>
          <td class="paramname"><em>before_launch_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <code>spawn</code> when used to create a class-based actor (usually should not be called by users of the library). </p>
<p>This function simply forwards its arguments to <code>spawn_impl</code> using <code>spawn_fwd</code>. </p>

</div>
</div>
<a class="anchor" id="a440bd9d2effba7d4903e049b56d25e7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;spawn_options Os, typename BeforeLaunch , typename F , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaf_1_1actor.html">actor</a> caf::spawn_functor </td>
          <td>(</td>
          <td class="paramtype">execution_unit *&#160;</td>
          <td class="paramname"><em>eu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeforeLaunch&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <code>spawn</code> when used to create a functor-based actor (usually should not be called by users of the library). </p>
<p>This function selects a proper implementation class and then delegates to <code>spawn_class</code>. </p>

</div>
</div>
<a class="anchor" id="a7d8be7640442e7994c2d74a3eb614720"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , spawn_options Os, class BeforeLaunch , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt;C&gt; caf::spawn_impl </td>
          <td>(</td>
          <td class="paramtype">execution_unit *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeforeLaunch&#160;</td>
          <td class="paramname"><em>before_launch_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a newly spawned instance of type <code>C</code> using <code>args...</code> as constructor arguments. </p>
<p>The instance will be added to the job list of <code>host</code>. However, before the instance is launched, <code>before_launch_fun</code> will be called, e.g., to join a group before the actor is running. </p>

</div>
</div>
<a class="anchor" id="a96b70be2266ad1a24e5cfcccc471f7f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ caf::val </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wildcard that matches any value of type <code>T</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="">Math Actor Example</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_1_8cpp-example.html#a1">announce_1.cpp</a>, <a class="el" href="announce_2_8cpp-example.html#a0">announce_2.cpp</a>, <a class="el" href="announce_3_8cpp-example.html#a0">announce_3.cpp</a>, and <a class="el" href="announce_4_8cpp-example.html#a0">announce_4.cpp</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aa07320f4a961c5791979c4b44a73b50f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __unspecified__ caf::arg_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wildcard that matches the argument types of a given callback. </p>
<p>Must be the last argument to <a class="el" href="namespacecaf.html#a68584d36bba7035718fcf255199e3be6">on()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="">Math Actor Example</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a3">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a96e60be904990d765d5f7744a2c70a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __unspecified__ caf::on_arg_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression. </p>
<p>Equal to `on(arg_match). </p>

</div>
</div>
<a class="anchor" id="a6018a4e383cbbd501ffa7d520a5a6dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classcaf_1_1spawn__options.html">spawn_options</a> caf::priority_aware = spawn_options::priority_aware_flag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the new actor to evaluate message priorities. </p>
<dl class="section note"><dt>Note</dt><dd>This implicitly causes the actor to run in its own thread. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 28 2014 03:24:07 for libcaf by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
