<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libcppa: cppa Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libcppa
   &#160;<span id="projectnumber">Version 0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cppa Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Root namespace of libcppa.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecppa_1_1exit__reason"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1exit__reason.html">exit_reason</a></td></tr>
<tr class="memdesc:namespacecppa_1_1exit__reason"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all predefined exit reasons. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1factory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1factory.html">factory</a></td></tr>
<tr class="memdesc:namespacecppa_1_1factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains factory functions to create actors from lambdas or other functors. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1intrusive"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1intrusive.html">intrusive</a></td></tr>
<tr class="memdesc:namespacecppa_1_1intrusive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains intrusive container implementations. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1network"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1network.html">network</a></td></tr>
<tr class="memdesc:namespacecppa_1_1network"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all network related classes. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1opencl.html">opencl</a></td></tr>
<tr class="memdesc:namespacecppa_1_1opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all classes of libcppa's OpenCL binding (optional). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1placeholders"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1placeholders.html">placeholders</a></td></tr>
<tr class="memdesc:namespacecppa_1_1placeholders"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the guard placeholders <code>_x1</code> to <code>_x9</code>. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1util"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1util.html">util</a></td></tr>
<tr class="memdesc:namespacecppa_1_1util"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utility classes and metaprogramming utilities used by the libcppa implementation. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1abstract__actor.html">abstract_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all actor implementations.  <a href="classcppa_1_1abstract__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1abstract__channel.html">abstract_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all message receivers.  <a href="classcppa_1_1abstract__channel.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1abstract__group.html">abstract_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multicast group.  <a href="classcppa_1_1abstract__group.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor.html">actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an untyped actor.  <a href="classcppa_1_1actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1invalid__actor__addr__t.html">invalid_actor_addr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an invalid <a class="el" href="classcppa_1_1actor__addr.html">actor_addr</a>.  <a href="structcppa_1_1invalid__actor__addr__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__addr.html">actor_addr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the address of typed as well as untyped actors.  <a href="classcppa_1_1actor__addr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__companion.html">actor_companion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An co-existing forwarding all messages through a user-defined callback to another object, thus serving as gateway to allow any object to interact with other actors.  <a href="classcppa_1_1actor__companion.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__namespace.html">actor_namespace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups a (distributed) set of actors and allows actors in the same namespace to exchange messages.  <a href="classcppa_1_1actor__namespace.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__proxy.html">actor_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a remote actor.  <a href="classcppa_1_1actor__proxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a fixed-length copy-on-write tuple with elements of any type.  <a href="classcppa_1_1any__tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1anything.html">anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acts as wildcard expression in patterns.  <a href="structcppa_1_1anything.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1is__anything.html">is_anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks wheter <code>T</code> is <a class="el" href="structcppa_1_1anything.html">anything</a>.  <a href="structcppa_1_1is__anything.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1attachable.html">attachable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback utility class.  <a href="classcppa_1_1attachable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1behavior.html">behavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the behavior of an actor.  <a href="classcppa_1_1behavior.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1behavior__stack__based.html">behavior_stack_based</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin for actors using a stack-based message processing.  <a href="classcppa_1_1behavior__stack__based.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1binary__deserializer.html">binary_deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the deserializer interface with a binary serialization protocol.  <a href="classcppa_1_1binary__deserializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1binary__serializer.html">binary_serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the serializer interface with a binary serialization protocol.  <a href="classcppa_1_1binary__serializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1blocking__actor.html">blocking_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread-mapped or context-switching actor using a blocking receive rather than a behavior-stack based message processing.  <a href="classcppa_1_1blocking__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1channel.html">channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to instances of <a class="el" href="classcppa_1_1abstract__channel.html">abstract_channel</a>.  <a href="classcppa_1_1channel.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1continue__helper.html">continue_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to enable users to add continuations when dealing with synchronous sends.  <a href="classcppa_1_1continue__helper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cow__ptr.html">cow_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy-on-write smart pointer implementation.  <a href="classcppa_1_1cow__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cow__tuple_3_01_head_00_01_tail_8_8_8_4.html">cow_tuple&lt; Head, Tail...&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-length copy-on-write cow_tuple.  <a href="classcppa_1_1cow__tuple_3_01_head_00_01_tail_8_8_8_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an optional value of <code>T</code>.  <a href="classcppa_1_1optional.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive, reference counting smart pointer impelementation.  <a href="classcppa_1_1intrusive__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer that does not increase the reference count.  <a href="classcppa_1_1weak__intrusive__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1deserializer.html">deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent deserialization interface.  <a href="classcppa_1_1deserializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1enable__weak__ptr.html">enable_weak_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables derived classes to be used in <a class="el" href="classcppa_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>.  <a href="classcppa_1_1enable__weak__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1event__based__actor.html">event_based_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cooperatively scheduled, event-based actor implementation.  <a href="classcppa_1_1event__based__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cppa__exception.html">cppa_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for libcppa exceptions.  <a href="classcppa_1_1cppa__exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__exited.html">actor_exited</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown if an actor finished execution.  <a href="classcppa_1_1actor__exited.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1network__error.html">network_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate that either an actor publishing failed or <code>libcppa</code> was unable to connect to a remote host.  <a href="classcppa_1_1network__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1bind__failure.html">bind_failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate that an actor publishing failed because the requested port could not be used.  <a href="classcppa_1_1bind__failure.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1extend.html">extend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows convenient definition of types using mixins. For example, "extend&lt;ar, T&gt;::with&lt;ob, fo&gt;" is an alias for "fo&lt;ob&lt;ar, T&gt;, T&gt;".  <a href="structcppa_1_1extend.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1guard__placeholder.html">guard_placeholder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for guard expression.  <a href="structcppa_1_1guard__placeholder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1local__actor.html">local_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for local running Actors.  <a href="classcppa_1_1local__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A match expression encapsulating cases <code>Cs...</code>, whereas each case is a <code>detail::projection_partial_function_pair</code>.  <a href="classcppa_1_1match__expr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1memory__cached.html">memory_cached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin adds all member functions and member variables needed by the memory management subsystem.  <a href="classcppa_1_1memory__cached.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1memory__managed.html">memory_managed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base enables derived classes to enforce a different allocation strategy than new/delete by providing a virtual protected <code><a class="el" href="classcppa_1_1memory__managed.html#ae14e5c4be622520c604a9ac69f0c9478" title="Default implementations calls delete this, but can be overriden in case deletion depends on some cond...">request_deletion()</a></code> function and non-public destructor.  <a href="classcppa_1_1memory__managed.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1message__header.html">message_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates information about sender, receiver and (synchronous) message ID of a message. The message itself is usually an <a class="el" href="classcppa_1_1any__tuple.html" title="Describes a fixed-length copy-on-write tuple with elements of any type. ">any_tuple</a>.  <a href="classcppa_1_1message__header.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1message__id.html">message_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes whether a message is asynchronous or synchronous.  <a href="classcppa_1_1message__id.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1node__id.html">node_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a process.  <a href="classcppa_1_1node__id.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1object.html">object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction class that stores an instance of an announced type.  <a href="classcppa_1_1object.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1option__info.html">option_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a help text along with the number of expected arguments.  <a href="structcppa_1_1option__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1is__optional.html">is_optional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1optional__variant.html">optional_variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcppa_1_1optional__variant.html" title="A optional_variant is either invalid or holds a value of one of the types Ts. ">optional_variant</a> is either invalid or holds a value of one of the types <code>Ts</code>.  <a href="classcppa_1_1optional__variant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1partial__function.html">partial_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial function implementation for <a class="el" href="classcppa_1_1any__tuple.html">any_tuples</a>.  <a href="classcppa_1_1partial__function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An union container for primitive data types.  <a href="classcppa_1_1primitive__variant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1ref__counted.html">ref_counted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (thread safe) base class for reference counted objects with an atomic reference count.  <a href="classcppa_1_1ref__counted.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1nonblocking__response__handle__tag.html">nonblocking_response_handle_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tag identifies response handles featuring a nonblocking API by providing a <code>then</code> member function.  <a href="structcppa_1_1nonblocking__response__handle__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1blocking__response__handle__tag.html">blocking_response_handle_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tag identifies response handles featuring a blocking API by providing an <code>await</code> member function.  <a href="structcppa_1_1blocking__response__handle__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1response__handle.html">response_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper class identifies an expected response message and enables <code>sync_send(...).then(...)</code>.  <a href="classcppa_1_1response__handle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1response__promise.html">response_promise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A response promise can be used to deliver a uniquely identifiable response message from the server (i.e. receiver of the request) to the client (i.e. the sender of the request).  <a href="classcppa_1_1response__promise.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1resumable.html">resumable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cooperatively executed task managed by one or more instances of <a class="el" href="">execution_unit</a>.  <a href="classcppa_1_1resumable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1sb__actor.html">sb_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for state-based actors using the Curiously Recurring Template Pattern to initialize the derived actor with its <code>init_state</code> member.  <a href="classcppa_1_1sb__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1scoped__actor.html">scoped_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scoped handle to a blocking actor.  <a href="classcppa_1_1scoped__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1serializer.html">serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent serialization interface.  <a href="classcppa_1_1serializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1single__timeout.html">single_timeout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin for actors using a non-nestable message processing.  <a href="classcppa_1_1single__timeout.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1skip__message__t.html">skip_message_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional return type for functors used in pattern matching expressions. This type is evaluated by the runtime system of libcppa and can be used to intentionally skip messages.  <a href="structcppa_1_1skip__message__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores options passed to the <code>spawn</code> function family.  <a href="classcppa_1_1spawn__options.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1exit__msg.html">exit_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent to all links when an actor is terminated.  <a href="structcppa_1_1exit__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1down__msg.html">down_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent to all actors monitoring an actor when it is terminated.  <a href="structcppa_1_1down__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1group__down__msg.html">group_down_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent to all members of a group when it goes offline.  <a href="structcppa_1_1group__down__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1sync__timeout__msg.html">sync_timeout_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent whenever a timeout occurs during a synchronous send.  <a href="structcppa_1_1sync__timeout__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1sync__exited__msg.html">sync_exited_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent whenever a terminated actor receives a synchronous request.  <a href="structcppa_1_1sync__exited__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1timeout__msg.html">timeout_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signalizes a timeout event.  <a href="structcppa_1_1timeout__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1new__connection__msg.html">new_connection_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signalizes a newly accepted connection from a <a class="el" href="">broker</a>.  <a href="structcppa_1_1new__connection__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1new__data__msg.html">new_data_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signalizes newly arrived data for a <a class="el" href="">broker</a>.  <a href="structcppa_1_1new__data__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1connection__closed__msg.html">connection_closed_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signalizes that a <a class="el" href="">broker</a> connection has been closed.  <a href="structcppa_1_1connection__closed__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1acceptor__closed__msg.html">acceptor_closed_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signalizes that a <a class="el" href="">broker</a> acceptor has been closed.  <a href="structcppa_1_1acceptor__closed__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1type__lookup__table.html">type_lookup_table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1typed__event__based__actor.html">typed_event_based_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cooperatively scheduled, event-based actor implementation with strong type checking.  <a href="classcppa_1_1typed__event__based__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1typed__actor.html">typed_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a strongly typed actor.  <a href="classcppa_1_1typed__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a platform independent type name and a (very primitive) kind of reflection in combination with <a class="el" href="classcppa_1_1object.html">object</a>.  <a href="classcppa_1_1uniform__type__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1weak__ptr__anchor.html">weak_ptr_anchor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A storage holding a spinlock and a pointer to a reference counted object.  <a href="classcppa_1_1weak__ptr__anchor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aee713e441d2e98815a3b03dc716cd6e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee713e441d2e98815a3b03dc716cd6e7"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1abstract__actor.html">abstract_actor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>abstract_actor_ptr</b></td></tr>
<tr class="separator:aee713e441d2e98815a3b03dc716cd6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46190b719f248a02b0dcf748ac76b10f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46190b719f248a02b0dcf748ac76b10f"></a>
typedef behavior_policy&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keep_behavior_t</b></td></tr>
<tr class="separator:a46190b719f248a02b0dcf748ac76b10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea2a0fe3f2f2a7f451d667a22b5940e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea2a0fe3f2f2a7f451d667a22b5940e"></a>
typedef behavior_policy&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>discard_behavior_t</b></td></tr>
<tr class="separator:a7ea2a0fe3f2f2a7f451d667a22b5940e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948e3ea11df8e64e9a0e0204d3d52539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a948e3ea11df8e64e9a0e0204d3d52539"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>native_socket_type</b></td></tr>
<tr class="separator:a948e3ea11df8e64e9a0e0204d3d52539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901753d5129887d9d6161985f4c319e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a901753d5129887d9d6161985f4c319e2"></a>
typedef const void *&#160;</td><td class="memItemRight" valign="bottom"><b>setsockopt_ptr</b></td></tr>
<tr class="separator:a901753d5129887d9d6161985f4c319e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8212243ffb4995abddd7850f47863b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8212243ffb4995abddd7850f47863b1"></a>
typedef const void *&#160;</td><td class="memItemRight" valign="bottom"><b>socket_send_ptr</b></td></tr>
<tr class="separator:af8212243ffb4995abddd7850f47863b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cea4187e4fa345b7cad0ca5c8e08af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41cea4187e4fa345b7cad0ca5c8e08af"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><b>socket_recv_ptr</b></td></tr>
<tr class="separator:a41cea4187e4fa345b7cad0ca5c8e08af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1e48de4f094769b0668d247a99a7d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b1e48de4f094769b0668d247a99a7d6"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1abstract__group.html">abstract_group</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>abstract_group_ptr</b></td></tr>
<tr class="separator:a3b1e48de4f094769b0668d247a99a7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e828569dc53c27489a37f813d0386b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e828569dc53c27489a37f813d0386b9"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1actor__proxy.html">actor_proxy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>actor_proxy_ptr</b></td></tr>
<tr class="separator:a6e828569dc53c27489a37f813d0386b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8754a65da32fbbd08a05321a6fbe26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f8754a65da32fbbd08a05321a6fbe26"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcppa_1_1node__id.html">node_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_id_ptr</b></td></tr>
<tr class="separator:a8f8754a65da32fbbd08a05321a6fbe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70215037f92d25ce73b7a66413e5fa6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae70215037f92d25ce73b7a66413e5fa6"></a>
typedef <a class="el" href="classcppa_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1actor__proxy.html">actor_proxy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>weak_actor_proxy_ptr</b></td></tr>
<tr class="separator:ae70215037f92d25ce73b7a66413e5fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6444f13f198a99e8a11d32a61abf17f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6444f13f198a99e8a11d32a61abf17f1"></a>
typedef const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a6444f13f198a99e8a11d32a61abf17f1">msg_hdr_cref</a></td></tr>
<tr class="memdesc:a6444f13f198a99e8a11d32a61abf17f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedef. <br/></td></tr>
<tr class="separator:a6444f13f198a99e8a11d32a61abf17f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4595c2e431e79e82ecaf23faf7121610"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4595c2e431e79e82ecaf23faf7121610"></a>
typedef std::unique_ptr<br class="typebreak"/>
&lt; mailbox_element, <br class="typebreak"/>
detail::disposer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>unique_mailbox_element_pointer</b></td></tr>
<tr class="separator:a4595c2e431e79e82ecaf23faf7121610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac780fad19465067ad0dc34bc70b5e783"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac780fad19465067ad0dc34bc70b5e783"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
std::map&lt; std::pair&lt; char, <br class="typebreak"/>
std::string &gt;, <a class="el" href="structcppa_1_1option__info.html">option_info</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ac780fad19465067ad0dc34bc70b5e783">options_description</a></td></tr>
<tr class="memdesc:ac780fad19465067ad0dc34bc70b5e783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a help text for program options with option groups. <br/></td></tr>
<tr class="separator:ac780fad19465067ad0dc34bc70b5e783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7044eb06e2b94aaf9684d5d31e759f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f7044eb06e2b94aaf9684d5d31e759f"></a>
typedef timeout_definition<br class="typebreak"/>
&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generic_timeout_definition</b></td></tr>
<tr class="separator:a3f7044eb06e2b94aaf9684d5d31e759f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a64079da560a7bd85135c11ab521a4950"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a> : std::uint64_t </td></tr>
<tr class="memdesc:a64079da560a7bd85135c11ab521a4950"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type of atoms. <br/></td></tr>
<tr class="separator:a64079da560a7bd85135c11ab521a4950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32a52f8d2b456d1b5dbd2d0a3d3df34"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>operator_id</b> { <br/>
&#160;&#160;<b>addition_op</b>, 
<br/>
&#160;&#160;<b>subtraction_op</b>, 
<br/>
&#160;&#160;<b>multiplication_op</b>, 
<br/>
&#160;&#160;<b>division_op</b>, 
<br/>
&#160;&#160;<b>modulo_op</b>, 
<br/>
&#160;&#160;<b>less_op</b>, 
<br/>
&#160;&#160;<b>less_eq_op</b>, 
<br/>
&#160;&#160;<b>greater_op</b>, 
<br/>
&#160;&#160;<b>greater_eq_op</b>, 
<br/>
&#160;&#160;<b>equal_op</b>, 
<br/>
&#160;&#160;<b>not_equal_op</b>, 
<br/>
&#160;&#160;<b>logical_and_op</b>, 
<br/>
&#160;&#160;<b>logical_or_op</b>, 
<br/>
&#160;&#160;<b>exec_fun1_op</b>, 
<br/>
&#160;&#160;<b>exec_fun2_op</b>, 
<br/>
&#160;&#160;<b>exec_fun3_op</b>, 
<br/>
&#160;&#160;<b>exec_xfun_op</b>, 
<br/>
&#160;&#160;<b>dummy_op</b>
<br/>
 }</td></tr>
<tr class="separator:ae32a52f8d2b456d1b5dbd2d0a3d3df34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd1fdc77ec098cf1bee91bacaf8c89c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>message_priority</b> : std::uint32_t { <br/>
&#160;&#160;<b>normal</b>, 
<br/>
&#160;&#160;<b>high</b>
<br/>
 }</td></tr>
<tr class="separator:a7bd1fdc77ec098cf1bee91bacaf8c89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4405c08180f3db0936dcc6afe84f2899"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">primitive_type</a> : unsigned char { <br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899af3b4cd07f6e7b784ef327226d125f081">pt_int8</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899abe2fbca2e1841f8c22880cde2c00f542">pt_int16</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899aa0a3077bf98838f8565a3081bd45fe7a">pt_int32</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899adb00d323a0719b09a9b1e2b296bf7ee7">pt_int64</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a88cb8022596d4673fede279849a67c9e">pt_uint8</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ac2fefdb86c724a8fccdaf77295bdb786">pt_uint16</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a081be63f60008807f9a07df1d814704a">pt_uint32</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a05e7b1ff7b99a9f24ff8a44577745d59">pt_uint64</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a9c2885b0dd3095de04714bf6d791ed61">pt_float</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a840b02ba715ef3b798d3f1b6cb1dd1bc">pt_double</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899afaa2282a22514a0934a3571b4e4cc75d">pt_long_double</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a93531ba3275cbc0a4cfcb23a6bbe080e">pt_u8string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ab2a366dcc7a5b7ee1162fd024d6f722e">pt_u16string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ac04250078e159cbbb285ad3a39aae4ce">pt_u32string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a8b7d0c7bdeab0ac7b90d756827b95cb4">pt_atom</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a494ed640f1e094e7db23a9ce2f3f199b">pt_null</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga4405c08180f3db0936dcc6afe84f2899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type flag of <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a>.  <a href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">More...</a><br/></td></tr>
<tr class="separator:ga4405c08180f3db0936dcc6afe84f2899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab63f2274711ea5cce959c91d793b25"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a> { <br/>
&#160;&#160;<b>nil</b>, 
<br/>
&#160;&#160;<b>trailing</b>, 
<br/>
&#160;&#160;<b>leading</b>, 
<br/>
&#160;&#160;<b>in_between</b>, 
<br/>
&#160;&#160;<b>multiple</b>
<br/>
 }</td></tr>
<tr class="memdesc:a5ab63f2274711ea5cce959c91d793b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes the position of <a class="el" href="structcppa_1_1anything.html">anything</a> in a template parameter pack. <br/></td></tr>
<tr class="separator:a5ab63f2274711ea5cce959c91d793b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8b7cb8011a32265af0252f53b7a4da67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a8b7cb8011a32265af0252f53b7a4da67">publish_local_groups</a> (std::uint16_t port, const char *addr=nullptr)</td></tr>
<tr class="memdesc:a8b7cb8011a32265af0252f53b7a4da67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <em>all</em> local groups accessible via network on address <code>addr</code> and <code>port</code>.  <a href="#a8b7cb8011a32265af0252f53b7a4da67">More...</a><br/></td></tr>
<tr class="separator:a8b7cb8011a32265af0252f53b7a4da67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9359b2999e342be5136c575b52871fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9359b2999e342be5136c575b52871fa"></a>
actor_ostream&#160;</td><td class="memItemRight" valign="bottom"><b>aout</b> (<a class="el" href="classcppa_1_1actor.html">actor</a> self)</td></tr>
<tr class="separator:ae9359b2999e342be5136c575b52871fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5168c92d6bb51d74f61cea1253940cd6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga5168c92d6bb51d74f61cea1253940cd6">announce</a> (const std::type_info &amp;tinfo, std::unique_ptr&lt; <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> &gt; utype)</td></tr>
<tr class="memdesc:ga5168c92d6bb51d74f61cea1253940cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping to the libcppa type system.  <a href="group___type_system.html#ga5168c92d6bb51d74f61cea1253940cd6">More...</a><br/></td></tr>
<tr class="separator:ga5168c92d6bb51d74f61cea1253940cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , typename... Ts&gt; </td></tr>
<tr class="memitem:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C Parent::*, <br class="typebreak"/>
<a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#gaf92877da942d1a0f1944990cd3d67f7c">compound_member</a> (C Parent::*c_ptr, const Ts &amp;...args)</td></tr>
<tr class="memdesc:gaf92877da942d1a0f1944990cd3d67f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member <code>C</code>.  <a href="group___type_system.html#gaf92877da942d1a0f1944990cd3d67f7c">More...</a><br/></td></tr>
<tr class="separator:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , typename... Ts&gt; </td></tr>
<tr class="memitem:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C &amp;(Parent::*)(), <br class="typebreak"/>
<a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#gaf1400abaf4c109b60eba1f83d417b65c">compound_member</a> (C &amp;(Parent::*getter)(), const Ts &amp;...args)</td></tr>
<tr class="memdesc:gaf1400abaf4c109b60eba1f83d417b65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member accessed via a getter returning a mutable reference.  <a href="group___type_system.html#gaf1400abaf4c109b60eba1f83d417b65c">More...</a><br/></td></tr>
<tr class="separator:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="memTemplParams" colspan="2">template&lt;class Parent , typename GRes , typename SRes , typename SArg , typename... Ts&gt; </td></tr>
<tr class="memitem:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; GRes(Parent::*)() <br class="typebreak"/>
const, SRes(Parent::*)(SArg)&gt;<br class="typebreak"/>
, <a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1rm__const__and__ref.html">util::rm_const_and_ref</a>&lt; GRes &gt;<br class="typebreak"/>
::type &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga8f1d70c1c395b02cf3b668fbe103a593">compound_member</a> (const std::pair&lt; GRes(Parent::*)() const, SRes(Parent::*)(SArg) &gt; &amp;gspair, const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member accessed via a getter/setter pair.  <a href="group___type_system.html#ga8f1d70c1c395b02cf3b668fbe103a593">More...</a><br/></td></tr>
<tr class="separator:ga8f1d70c1c395b02cf3b668fbe103a593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="memTemplParams" colspan="2">template&lt;class C , typename... Ts&gt; </td></tr>
<tr class="memitem:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga855b3b9aeeb091f8f7db15fb0e012fb8">announce</a> (const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping for <code>C</code> to the libcppa type system.  <a href="group___type_system.html#ga855b3b9aeeb091f8f7db15fb0e012fb8">More...</a><br/></td></tr>
<tr class="separator:ga855b3b9aeeb091f8f7db15fb0e012fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2534a2a021d60eaa4519e36714d435af"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2534a2a021d60eaa4519e36714d435af"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ga2534a2a021d60eaa4519e36714d435af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga2534a2a021d60eaa4519e36714d435af">announce_tuple</a> ()</td></tr>
<tr class="memdesc:ga2534a2a021d60eaa4519e36714d435af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a hint to the type system of libcppa. This type hint can increase the network performance, because libcppa can use the hint to create tuples with full static type information rather than using fully dynamically typed tuples. <br/></td></tr>
<tr class="separator:ga2534a2a021d60eaa4519e36714d435af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cd5b37281764af3f24ba8ca297c2f3"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a28cd5b37281764af3f24ba8ca297c2f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a28cd5b37281764af3f24ba8ca297c2f3">make_any_tuple</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a28cd5b37281764af3f24ba8ca297c2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> containing the elements <code>args</code>.  <a href="#a28cd5b37281764af3f24ba8ca297c2f3">More...</a><br/></td></tr>
<tr class="separator:a28cd5b37281764af3f24ba8ca297c2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> (const <a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a> &amp;what)</td></tr>
<tr class="memdesc:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>what</code> as a string representation.  <a href="#a76a9f2873d0e97eb7ceffb6101e8e507">More...</a><br/></td></tr>
<tr class="separator:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed5b5aa07c384b14899beae80974d47"><td class="memTemplParams" colspan="2">template&lt;size_t Size&gt; </td></tr>
<tr class="memitem:a9ed5b5aa07c384b14899beae80974d47"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47">atom</a> (char const (&amp;str)[Size])</td></tr>
<tr class="memdesc:a9ed5b5aa07c384b14899beae80974d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an atom from given string literal.  <a href="#a9ed5b5aa07c384b14899beae80974d47">More...</a><br/></td></tr>
<tr class="separator:a9ed5b5aa07c384b14899beae80974d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b4784ba07763f01be809c40be5337d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a14b4784ba07763f01be809c40be5337d"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a14b4784ba07763f01be809c40be5337d"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a14b4784ba07763f01be809c40be5337d">create_unique</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a14b4784ba07763f01be809c40be5337d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative for the 'missing' <code>std::make_unqiue</code>. <br/></td></tr>
<tr class="separator:a14b4784ba07763f01be809c40be5337d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f35f5fe58e287026a0149f341e8e3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f35f5fe58e287026a0149f341e8e3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>closesocket</b> (native_socket_type fd)</td></tr>
<tr class="separator:a41f35f5fe58e287026a0149f341e8e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d05ac9f699bfed65afdadab0a16a70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76d05ac9f699bfed65afdadab0a16a70"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>last_socket_error</b> ()</td></tr>
<tr class="separator:a76d05ac9f699bfed65afdadab0a16a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a30872d1a4a4ccf2afb68065d1d9df4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a30872d1a4a4ccf2afb68065d1d9df4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>would_block_or_temporarily_unavailable</b> (int errcode)</td></tr>
<tr class="separator:a3a30872d1a4a4ccf2afb68065d1d9df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbbf5f2cad68cd4efa2f07580d66aeb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdbbf5f2cad68cd4efa2f07580d66aeb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#acdbbf5f2cad68cd4efa2f07580d66aeb">send_tuple_as</a> (const <a class="el" href="classcppa_1_1actor.html">actor</a> &amp;from, const <a class="el" href="classcppa_1_1channel.html">channel</a> &amp;to, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> msg)</td></tr>
<tr class="memdesc:acdbbf5f2cad68cd4efa2f07580d66aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>to</code> a message under the identity of <code>from</code>. <br/></td></tr>
<tr class="separator:acdbbf5f2cad68cd4efa2f07580d66aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6c2b0620a0b0e3d702283fefbe4aa6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab6c2b0620a0b0e3d702283fefbe4aa6"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:aab6c2b0620a0b0e3d702283fefbe4aa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aab6c2b0620a0b0e3d702283fefbe4aa6">send_as</a> (const <a class="el" href="classcppa_1_1actor.html">actor</a> &amp;from, const <a class="el" href="classcppa_1_1channel.html">channel</a> &amp;to, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:aab6c2b0620a0b0e3d702283fefbe4aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>to</code> a message under the identity of <code>from</code>. <br/></td></tr>
<tr class="separator:aab6c2b0620a0b0e3d702283fefbe4aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac22a602a1d2e4090ffc3c8696636dff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac22a602a1d2e4090ffc3c8696636dff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aac22a602a1d2e4090ffc3c8696636dff">anon_send_tuple</a> (const <a class="el" href="classcppa_1_1channel.html">channel</a> &amp;to, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> msg)</td></tr>
<tr class="memdesc:aac22a602a1d2e4090ffc3c8696636dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>to</code> a message. <br/></td></tr>
<tr class="separator:aac22a602a1d2e4090ffc3c8696636dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcfdd0e339d49d34359f65ac2ccae04"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6dcfdd0e339d49d34359f65ac2ccae04"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a6dcfdd0e339d49d34359f65ac2ccae04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a6dcfdd0e339d49d34359f65ac2ccae04">anon_send</a> (const <a class="el" href="classcppa_1_1channel.html">channel</a> &amp;to, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a6dcfdd0e339d49d34359f65ac2ccae04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>to</code> a message. <br/></td></tr>
<tr class="separator:a6dcfdd0e339d49d34359f65ac2ccae04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9438546a867b3578ae496f205b00ebca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9438546a867b3578ae496f205b00ebca">max_msg_size</a> (size_t size)</td></tr>
<tr class="memdesc:a9438546a867b3578ae496f205b00ebca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum size of a message over network.  <a href="#a9438546a867b3578ae496f205b00ebca">More...</a><br/></td></tr>
<tr class="separator:a9438546a867b3578ae496f205b00ebca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab092984b6f7e5ee28f07b0b6835e4bdf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab092984b6f7e5ee28f07b0b6835e4bdf">max_msg_size</a> ()</td></tr>
<tr class="memdesc:ab092984b6f7e5ee28f07b0b6835e4bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the maximum size of messages over network.  <a href="#ab092984b6f7e5ee28f07b0b6835e4bdf">More...</a><br/></td></tr>
<tr class="separator:ab092984b6f7e5ee28f07b0b6835e4bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2acfbc47c461fcb7905b025132e145"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc2acfbc47c461fcb7905b025132e145"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#adc2acfbc47c461fcb7905b025132e145">anon_send_exit</a> (const <a class="el" href="classcppa_1_1actor__addr.html">actor_addr</a> &amp;whom, std::uint32_t reason)</td></tr>
<tr class="memdesc:adc2acfbc47c461fcb7905b025132e145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>whom</code> an exit message. <br/></td></tr>
<tr class="separator:adc2acfbc47c461fcb7905b025132e145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95ac18367610afc3b134a204b86cbb7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa95ac18367610afc3b134a204b86cbb7"></a>
template&lt;typename ActorHandle &gt; </td></tr>
<tr class="memitem:aa95ac18367610afc3b134a204b86cbb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aa95ac18367610afc3b134a204b86cbb7">anon_send_exit</a> (const ActorHandle &amp;whom, std::uint32_t reason)</td></tr>
<tr class="memdesc:aa95ac18367610afc3b134a204b86cbb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>whom</code> an exit message. <br/></td></tr>
<tr class="separator:aa95ac18367610afc3b134a204b86cbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1155a80c876121987be19d4f38c4dacd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1155a80c876121987be19d4f38c4dacd">await_all_actors_done</a> ()</td></tr>
<tr class="memdesc:a1155a80c876121987be19d4f38c4dacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks execution of this actor until all other actors finished execution.  <a href="#a1155a80c876121987be19d4f38c4dacd">More...</a><br/></td></tr>
<tr class="separator:a1155a80c876121987be19d4f38c4dacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21eb626925475d80514ebfc76a6b7dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab21eb626925475d80514ebfc76a6b7dc">publish</a> (<a class="el" href="classcppa_1_1actor.html">actor</a> whom, std::uint16_t port, const char *addr=nullptr)</td></tr>
<tr class="memdesc:ab21eb626925475d80514ebfc76a6b7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes <code>whom</code> at <code>port</code>.  <a href="#ab21eb626925475d80514ebfc76a6b7dc">More...</a><br/></td></tr>
<tr class="separator:ab21eb626925475d80514ebfc76a6b7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16429084be954d051667f2937ae5c93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ac16429084be954d051667f2937ae5c93">publish</a> (<a class="el" href="classcppa_1_1actor.html">actor</a> whom, std::unique_ptr&lt; <a class="el" href="classcppa_1_1io_1_1acceptor.html">io::acceptor</a> &gt; acceptor)</td></tr>
<tr class="memdesc:ac16429084be954d051667f2937ae5c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes <code>whom</code> using <code>acceptor</code> to handle incoming connections.  <a href="#ac16429084be954d051667f2937ae5c93">More...</a><br/></td></tr>
<tr class="separator:ac16429084be954d051667f2937ae5c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf7df3d1f181031ee52d9a9d51c869f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#afcf7df3d1f181031ee52d9a9d51c869f">remote_actor</a> (io::stream_ptr_pair connection)</td></tr>
<tr class="memdesc:afcf7df3d1f181031ee52d9a9d51c869f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to a remote actor via <code>connection</code>.  <a href="#afcf7df3d1f181031ee52d9a9d51c869f">More...</a><br/></td></tr>
<tr class="separator:afcf7df3d1f181031ee52d9a9d51c869f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944a72f93baaa731fcd939a5b693552b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a944a72f93baaa731fcd939a5b693552b">remote_actor</a> (const char *host, std::uint16_t port)</td></tr>
<tr class="memdesc:a944a72f93baaa731fcd939a5b693552b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor at <code>host</code> on given <code>port</code>.  <a href="#a944a72f93baaa731fcd939a5b693552b">More...</a><br/></td></tr>
<tr class="separator:a944a72f93baaa731fcd939a5b693552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec44c183aa21e561af941920095f4f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aaec44c183aa21e561af941920095f4f5">remote_actor</a> (const std::string &amp;host, std::uint16_t port)</td></tr>
<tr class="memdesc:aaec44c183aa21e561af941920095f4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor at <code>host</code> on given <code>port</code>.  <a href="#aaec44c183aa21e561af941920095f4f5">More...</a><br/></td></tr>
<tr class="separator:aaec44c183aa21e561af941920095f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c36bec69c79ad2680abbb26aaf3107a"><td class="memTemplParams" colspan="2">template&lt;typename... Rs&gt; </td></tr>
<tr class="memitem:a8c36bec69c79ad2680abbb26aaf3107a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a8c36bec69c79ad2680abbb26aaf3107a">typed_publish</a> (<a class="el" href="classcppa_1_1typed__actor.html">typed_actor</a>&lt; Rs...&gt; whom, std::unique_ptr&lt; <a class="el" href="classcppa_1_1io_1_1acceptor.html">io::acceptor</a> &gt; uptr)</td></tr>
<tr class="memdesc:a8c36bec69c79ad2680abbb26aaf3107a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes <code>whom</code> using <code>acceptor</code> to handle incoming connections.  <a href="#a8c36bec69c79ad2680abbb26aaf3107a">More...</a><br/></td></tr>
<tr class="separator:a8c36bec69c79ad2680abbb26aaf3107a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60d77e0d09df88575d4aaed94d822cf"><td class="memTemplParams" colspan="2">template&lt;typename... Rs&gt; </td></tr>
<tr class="memitem:ab60d77e0d09df88575d4aaed94d822cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab60d77e0d09df88575d4aaed94d822cf">typed_publish</a> (<a class="el" href="classcppa_1_1typed__actor.html">typed_actor</a>&lt; Rs...&gt; whom, std::uint16_t port, const char *addr=nullptr)</td></tr>
<tr class="memdesc:ab60d77e0d09df88575d4aaed94d822cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes <code>whom</code> at <code>port</code>.  <a href="#ab60d77e0d09df88575d4aaed94d822cf">More...</a><br/></td></tr>
<tr class="separator:ab60d77e0d09df88575d4aaed94d822cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1319c0de9f9a711b892897e86395252"><td class="memTemplParams" colspan="2">template&lt;class List &gt; </td></tr>
<tr class="memitem:ae1319c0de9f9a711b892897e86395252"><td class="memTemplItemLeft" align="right" valign="top">detail::typed_remote_actor_helper<br class="typebreak"/>
&lt; List &gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ae1319c0de9f9a711b892897e86395252">typed_remote_actor</a> (io::stream_ptr_pair connection)</td></tr>
<tr class="memdesc:ae1319c0de9f9a711b892897e86395252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to a remote actor via <code>connection</code>.  <a href="#ae1319c0de9f9a711b892897e86395252">More...</a><br/></td></tr>
<tr class="separator:ae1319c0de9f9a711b892897e86395252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ab57d6901052a5756b072b56f53f2d"><td class="memTemplParams" colspan="2">template&lt;class List &gt; </td></tr>
<tr class="memitem:a01ab57d6901052a5756b072b56f53f2d"><td class="memTemplItemLeft" align="right" valign="top">detail::typed_remote_actor_helper<br class="typebreak"/>
&lt; List &gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a01ab57d6901052a5756b072b56f53f2d">typed_remote_actor</a> (const char *host, std::uint16_t port)</td></tr>
<tr class="memdesc:a01ab57d6901052a5756b072b56f53f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor at <code>host</code> on given <code>port</code>.  <a href="#a01ab57d6901052a5756b072b56f53f2d">More...</a><br/></td></tr>
<tr class="separator:a01ab57d6901052a5756b072b56f53f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07202c8ac584a09538d39b2f1ef7de3"><td class="memTemplParams" colspan="2">template&lt;class List &gt; </td></tr>
<tr class="memitem:ac07202c8ac584a09538d39b2f1ef7de3"><td class="memTemplItemLeft" align="right" valign="top">detail::typed_remote_actor_helper<br class="typebreak"/>
&lt; List &gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ac07202c8ac584a09538d39b2f1ef7de3">typed_remote_actor</a> (const std::string &amp;host, std::uint16_t port)</td></tr>
<tr class="memdesc:ac07202c8ac584a09538d39b2f1ef7de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor at <code>host</code> on given <code>port</code>.  <a href="#ac07202c8ac584a09538d39b2f1ef7de3">More...</a><br/></td></tr>
<tr class="separator:ac07202c8ac584a09538d39b2f1ef7de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b85364d69c55cc6ac51b2d0780293d6"><td class="memTemplParams" colspan="2">template&lt;spawn_options Os = no_spawn_options, typename F  = std::function&lt;void (io::broker*)&gt;, typename... Ts&gt; </td></tr>
<tr class="memitem:a2b85364d69c55cc6ac51b2d0780293d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a2b85364d69c55cc6ac51b2d0780293d6">spawn_io</a> (F fun, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a2b85364d69c55cc6ac51b2d0780293d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new, function-based IO actor.  <a href="#a2b85364d69c55cc6ac51b2d0780293d6">More...</a><br/></td></tr>
<tr class="separator:a2b85364d69c55cc6ac51b2d0780293d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced49bb8d987c1484fd446b37714edb8"><td class="memTemplParams" colspan="2">template&lt;spawn_options Os = no_spawn_options, typename F  = std::function&lt;void (io::broker*)&gt;, typename... Ts&gt; </td></tr>
<tr class="memitem:aced49bb8d987c1484fd446b37714edb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aced49bb8d987c1484fd446b37714edb8">spawn_io_client</a> (F fun, <a class="el" href="classcppa_1_1intrusive__ptr.html">io::input_stream_ptr</a> in, <a class="el" href="classcppa_1_1intrusive__ptr.html">io::output_stream_ptr</a> out, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:aced49bb8d987c1484fd446b37714edb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new, function-based IO actor.  <a href="#aced49bb8d987c1484fd446b37714edb8">More...</a><br/></td></tr>
<tr class="separator:aced49bb8d987c1484fd446b37714edb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad416fa56d05d5ca4abc88fd8d4764f20"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad416fa56d05d5ca4abc88fd8d4764f20"></a>
template&lt;spawn_options Os = no_spawn_options, typename F  = std::function&lt;void (io::broker*)&gt;, typename... Ts&gt; </td></tr>
<tr class="memitem:ad416fa56d05d5ca4abc88fd8d4764f20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_io_client</b> (F fun, const std::string &amp;host, uint16_t port, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:ad416fa56d05d5ca4abc88fd8d4764f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7554af36fd39712a2fbdd27a409e24ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7554af36fd39712a2fbdd27a409e24ef"></a>
template&lt;spawn_options Os = no_spawn_options, typename F  = std::function&lt;void (io::broker*)&gt;, typename... Ts&gt; </td></tr>
<tr class="memitem:a7554af36fd39712a2fbdd27a409e24ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_io_server</b> (F fun, uint16_t port, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:a7554af36fd39712a2fbdd27a409e24ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5daac288a10cc34286f505ea637571"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d5daac288a10cc34286f505ea637571"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a8d5daac288a10cc34286f505ea637571">shutdown</a> ()</td></tr>
<tr class="memdesc:a8d5daac288a10cc34286f505ea637571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all singletons, disconnects all peers and stops the scheduler. It is recommended to use this function as very last function call before leaving main(). Especially in programs using libcppa's networking infrastructure. <br/></td></tr>
<tr class="separator:a8d5daac288a10cc34286f505ea637571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa221547ef879ba5b42f7cc7820f90e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aaa221547ef879ba5b42f7cc7820f90e1">from_string</a> (const std::string &amp;what)</td></tr>
<tr class="memdesc:aaa221547ef879ba5b42f7cc7820f90e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string created by <a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> to its original value.  <a href="#aaa221547ef879ba5b42f7cc7820f90e1">More...</a><br/></td></tr>
<tr class="separator:aaa221547ef879ba5b42f7cc7820f90e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21ab9e2f184e710548682e60d194053"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab21ab9e2f184e710548682e60d194053"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:ab21ab9e2f184e710548682e60d194053"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;<br class="typebreak"/>
::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const detail::tdata&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:ab21ab9e2f184e710548682e60d194053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529b5f85f7a7b0899f0fbb9b3bbf11f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a529b5f85f7a7b0899f0fbb9b3bbf11f5"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a529b5f85f7a7b0899f0fbb9b3bbf11f5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;<br class="typebreak"/>
::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const cow_tuple&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:a529b5f85f7a7b0899f0fbb9b3bbf11f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6f2665d3e0bece6ab055d20cf30e4c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f6f2665d3e0bece6ab055d20cf30e4c"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a3f6f2665d3e0bece6ab055d20cf30e4c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;<br class="typebreak"/>
::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const detail::pseudo_tuple&lt; Ts...&gt; &amp;tv)</td></tr>
<tr class="separator:a3f6f2665d3e0bece6ab055d20cf30e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7fa77d8ef1b9e193ea4c36851c1df3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e7fa77d8ef1b9e193ea4c36851c1df3"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a1e7fa77d8ef1b9e193ea4c36851c1df3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a>&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:a1e7fa77d8ef1b9e193ea4c36851c1df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554705905154ae92cdb3e31280a17554"><td class="memTemplParams" colspan="2"><a class="anchor" id="a554705905154ae92cdb3e31280a17554"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a554705905154ae92cdb3e31280a17554"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (detail::tdata&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:a554705905154ae92cdb3e31280a17554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa107053e5101889fb6707b24b792f1b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa107053e5101889fb6707b24b792f1b5"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:aa107053e5101889fb6707b24b792f1b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (cow_tuple&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:aa107053e5101889fb6707b24b792f1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82f5eafdc520298a1fcf0848d5c42b7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa82f5eafdc520298a1fcf0848d5c42b7"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:aa82f5eafdc520298a1fcf0848d5c42b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcppa_1_1util_1_1type__at.html">util::type_at</a>&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (detail::pseudo_tuple&lt; Ts...&gt; &amp;tv)</td></tr>
<tr class="separator:aa82f5eafdc520298a1fcf0848d5c42b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b50642f923d63806735ee22b9f2be8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3b50642f923d63806735ee22b9f2be8"></a>
template&lt;size_t Pos, typename... Ts&gt; </td></tr>
<tr class="memitem:ab3b50642f923d63806735ee22b9f2be8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (std::tuple&lt; Ts...&gt; &amp;tup) -&gt; decltype(std::get&lt; Pos &gt;(tup))</td></tr>
<tr class="separator:ab3b50642f923d63806735ee22b9f2be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c29a3f51ac8a87ac927f436dd6d808"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab8c29a3f51ac8a87ac927f436dd6d808"></a>
template&lt;size_t Pos, class Tuple &gt; </td></tr>
<tr class="memitem:ab8c29a3f51ac8a87ac927f436dd6d808"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab8c29a3f51ac8a87ac927f436dd6d808">get_cv_aware</a> (Tuple &amp;tup) -&gt; decltype(util::unwrap_ref(get_ref&lt; Pos &gt;(tup)))</td></tr>
<tr class="memdesc:ab8c29a3f51ac8a87ac927f436dd6d808"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function grants either const or non-const access to <code>tup</code>, depending on the cv-qualifier of <code>tup</code>. <br/></td></tr>
<tr class="separator:ab8c29a3f51ac8a87ac927f436dd6d808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf201347b3467771d054431bf778e6c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2cf201347b3467771d054431bf778e6c"></a>
template&lt;size_t Pos, class Tuple &gt; </td></tr>
<tr class="memitem:a2cf201347b3467771d054431bf778e6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a2cf201347b3467771d054431bf778e6c">get_cv_aware</a> (const Tuple &amp;tup) -&gt; decltype(util::unwrap_ref(get&lt; Pos &gt;(tup)))</td></tr>
<tr class="memdesc:a2cf201347b3467771d054431bf778e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function grants either const or non-const access to <code>tup</code>, depending on the cv-qualifier of <code>tup</code>. <br/></td></tr>
<tr class="separator:a2cf201347b3467771d054431bf778e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ab2c74affc2496609bacf3be1f46de"><td class="memTemplParams" colspan="2"><a class="anchor" id="a17ab2c74affc2496609bacf3be1f46de"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17ab2c74affc2496609bacf3be1f46de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1util_1_1rebindable__reference.html">util::rebindable_reference</a><br class="typebreak"/>
&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a17ab2c74affc2496609bacf3be1f46de">gref</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a17ab2c74affc2496609bacf3be1f46de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference wrapper similar to std::reference_wrapper&lt;const T&gt; that could be used in guard expressions or to enforce lazy evaluation. <br/></td></tr>
<tr class="separator:a17ab2c74affc2496609bacf3be1f46de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef395eaa7bd389ba17e28867010b5a7e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef395eaa7bd389ba17e28867010b5a7e"></a>
template&lt;typename Fun , typename T1 &gt; </td></tr>
<tr class="memitem:aef395eaa7bd389ba17e28867010b5a7e"><td class="memTemplItemLeft" align="right" valign="top">gcall1&lt; Fun, T1 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aef395eaa7bd389ba17e28867010b5a7e">gcall</a> (Fun fun, T1 t1)</td></tr>
<tr class="memdesc:aef395eaa7bd389ba17e28867010b5a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="separator:aef395eaa7bd389ba17e28867010b5a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a444ff11a730b8c1d42d5499c8fd36ed0"></a>
template&lt;typename Fun , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memTemplItemLeft" align="right" valign="top">gcall2&lt; Fun, T1, T2 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a444ff11a730b8c1d42d5499c8fd36ed0">gcall</a> (Fun fun, T1 t1, T2 t2)</td></tr>
<tr class="memdesc:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="separator:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb38db3897563dd010b0159b7598ce24"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb38db3897563dd010b0159b7598ce24"></a>
template&lt;typename Fun , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:afb38db3897563dd010b0159b7598ce24"><td class="memTemplItemLeft" align="right" valign="top">gcall3&lt; Fun, T1, T2, T3 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#afb38db3897563dd010b0159b7598ce24">gcall</a> (Fun fun, T1 t1, T2 t2, T3 t3)</td></tr>
<tr class="memdesc:afb38db3897563dd010b0159b7598ce24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="separator:afb38db3897563dd010b0159b7598ce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0966a88da87efe71b9d16a95cfee6bb4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0966a88da87efe71b9d16a95cfee6bb4"></a>
template&lt;typename Fun &gt; </td></tr>
<tr class="memitem:a0966a88da87efe71b9d16a95cfee6bb4"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; exec_xfun_op, Fun, <br class="typebreak"/>
unit_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a0966a88da87efe71b9d16a95cfee6bb4">ge_sub_function</a> (Fun fun)</td></tr>
<tr class="memdesc:a0966a88da87efe71b9d16a95cfee6bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>fun</code> with all arguments given to the guard expression. The functor <code>fun</code> must return a boolean. <br/></td></tr>
<tr class="separator:a0966a88da87efe71b9d16a95cfee6bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832d63b8b90c03075666e5b709805222"><td class="memTemplParams" colspan="2"><a class="anchor" id="a832d63b8b90c03075666e5b709805222"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a832d63b8b90c03075666e5b709805222"><td class="memTemplItemLeft" align="right" valign="top">ge_value&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gval</b> (T <a class="el" href="namespacecppa.html#af928936d573122345bc0737615f95f33">val</a>)</td></tr>
<tr class="separator:a832d63b8b90c03075666e5b709805222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6efd772c183821806213315e16c30c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aee6efd772c183821806213315e16c30c"></a>
template&lt;operator_id OP, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aee6efd772c183821806213315e16c30c"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; OP, typename <br class="typebreak"/>
detail::strip_and_convert&lt; T1 &gt;<br class="typebreak"/>
::type, typename <br class="typebreak"/>
detail::strip_and_convert&lt; T2 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_concatenate</b> (T1 first, T2 second, typename std::enable_if&lt; is_ge_type&lt; T1 &gt;::value||is_ge_type&lt; T2 &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:aee6efd772c183821806213315e16c30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ae21ec736d7c79de5bc814efab66ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55ae21ec736d7c79de5bc814efab66ca"></a>
template&lt;operator_id OP1, typename F1 , typename S1 , operator_id OP2, typename F2 , typename S2 &gt; </td></tr>
<tr class="memitem:a55ae21ec736d7c79de5bc814efab66ca"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; logical_and_op, <br class="typebreak"/>
guard_expr&lt; OP1, F1, S1 &gt;<br class="typebreak"/>
, guard_expr&lt; OP2, F2, S2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (guard_expr&lt; OP1, F1, S1 &gt; lhs, guard_expr&lt; OP2, F2, S2 &gt; rhs)</td></tr>
<tr class="separator:a55ae21ec736d7c79de5bc814efab66ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a628c9ea9c68a69a765e1c22ebab625b9"></a>
template&lt;operator_id OP1, typename F1 , typename S1 , operator_id OP2, typename F2 , typename S2 &gt; </td></tr>
<tr class="memitem:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; logical_or_op, <br class="typebreak"/>
guard_expr&lt; OP1, F1, S1 &gt;<br class="typebreak"/>
, guard_expr&lt; OP2, F2, S2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (guard_expr&lt; OP1, F1, S1 &gt; lhs, guard_expr&lt; OP2, F2, S2 &gt; rhs)</td></tr>
<tr class="separator:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3df0ac35ccc8aca49cfd042f977a375b"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const T &amp;value)</td></tr>
<tr class="separator:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44077174990342ce322b5c720af285a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a44077174990342ce322b5c720af285a7"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a44077174990342ce322b5c720af285a7"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const std::reference_wrapper&lt; T &gt; &amp;value)</td></tr>
<tr class="separator:a44077174990342ce322b5c720af285a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f4027bf874a6ff4ad23d688ffe08544"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const std::reference_wrapper&lt; const T &gt; &amp;value)</td></tr>
<tr class="separator:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dea78fc9947ec1611c055242acad42"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2dea78fc9947ec1611c055242acad42"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:af2dea78fc9947ec1611c055242acad42"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const <a class="el" href="classcppa_1_1util_1_1rebindable__reference.html">util::rebindable_reference</a>&lt; const T &gt; &amp;value)</td></tr>
<tr class="separator:af2dea78fc9947ec1611c055242acad42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2410091863897048954dde384e70df"><td class="memTemplParams" colspan="2"><a class="anchor" id="ace2410091863897048954dde384e70df"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:ace2410091863897048954dde384e70df"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const ge_value&lt; T &gt; &amp;wrapped_value)</td></tr>
<tr class="separator:ace2410091863897048954dde384e70df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89265fd784a63cdd2d9143c74e6f2f94"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89265fd784a63cdd2d9143c74e6f2f94"></a>
template&lt;class Tuple , int X&gt; </td></tr>
<tr class="memitem:a89265fd784a63cdd2d9143c74e6f2f94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;tup, <a class="el" href="structcppa_1_1guard__placeholder.html">guard_placeholder</a>&lt; X &gt;) -&gt; decltype(get&lt; X &gt;(tup).get())</td></tr>
<tr class="separator:a89265fd784a63cdd2d9143c74e6f2f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b5290d7cca52854f219727919d56d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83b5290d7cca52854f219727919d56d5"></a>
template&lt;class Tuple , operator_id OP, typename First , typename Second &gt; </td></tr>
<tr class="memitem:a83b5290d7cca52854f219727919d56d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;tup, const guard_expr&lt; OP, First, Second &gt; &amp;ge) -&gt; typename ge_result&lt; OP, First, Second, Tuple &gt;::type</td></tr>
<tr class="separator:a83b5290d7cca52854f219727919d56d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c3c9b3d2cf91e86fbefa608b71b6ed1"></a>
template&lt;operator_id OP, class Tuple , typename First , typename Second &gt; </td></tr>
<tr class="memitem:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memTemplItemLeft" align="right" valign="top">ge_result&lt; OP, First, Second, <br class="typebreak"/>
Tuple &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_eval</b> (const Tuple &amp;tup, const First &amp;lhs, const Second &amp;rhs)</td></tr>
<tr class="separator:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f59e94232ea05ac9753812211e33f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93f59e94232ea05ac9753812211e33f1"></a>
template&lt;operator_id OP, typename First , typename Second , typename... Ts&gt; </td></tr>
<tr class="memitem:a93f59e94232ea05ac9753812211e33f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_invoke_step2</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const detail::tdata&lt; Ts...&gt; &amp;tup) -&gt; typename ge_result&lt; OP, First, Second, detail::tdata&lt; Ts...&gt;&gt;::type</td></tr>
<tr class="separator:a93f59e94232ea05ac9753812211e33f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439d948767945bc2fccd61fe7bb31d44"><td class="memTemplParams" colspan="2"><a class="anchor" id="a439d948767945bc2fccd61fe7bb31d44"></a>
template&lt;operator_id OP, typename First , typename Second , typename... Ts&gt; </td></tr>
<tr class="memitem:a439d948767945bc2fccd61fe7bb31d44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_invoke</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const Ts &amp;...args) -&gt; typename ge_result&lt; OP, First, Second, detail::tdata&lt; std::reference_wrapper&lt; const Ts &gt;...&gt;&gt;::type</td></tr>
<tr class="separator:a439d948767945bc2fccd61fe7bb31d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2a82a93906c827b7ada3f6ffe195a56"></a>
template&lt;typename TupleTypes , operator_id OP, typename First , typename Second &gt; </td></tr>
<tr class="memitem:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memTemplItemLeft" align="right" valign="top">ge_result&lt; OP, First, Second, <br class="typebreak"/>
typename <br class="typebreak"/>
detail::tdata_from_type_list<br class="typebreak"/>
&lt; typename <a class="el" href="structcppa_1_1util_1_1tl__filter__not.html">util::tl_filter_not</a><br class="typebreak"/>
&lt; TupleTypes, <a class="el" href="structcppa_1_1is__anything.html">is_anything</a> &gt;<br class="typebreak"/>
::type &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_invoke_any</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &amp;tup)</td></tr>
<tr class="separator:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec9247a4f2fd10333c67831d57d6355"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ec9247a4f2fd10333c67831d57d6355"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a7ec9247a4f2fd10333c67831d57d6355"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; is_memory_cached&lt; T &gt;::value, <br class="typebreak"/>
<a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a7ec9247a4f2fd10333c67831d57d6355">make_counted</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7ec9247a4f2fd10333c67831d57d6355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T which must be a derived type of <a class="el" href="classcppa_1_1ref__counted.html">ref_counted</a> and wraps it in an <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>. <br/></td></tr>
<tr class="separator:a7ec9247a4f2fd10333c67831d57d6355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f244ace12cc81405ba240e2e3273c7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa1f244ace12cc81405ba240e2e3273c7"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:aa1f244ace12cc81405ba240e2e3273c7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; not <br class="typebreak"/>
is_memory_cached&lt; T &gt;::value, <br class="typebreak"/>
<a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_counted</b> (Ts &amp;&amp;...args)</td></tr>
<tr class="separator:aa1f244ace12cc81405ba240e2e3273c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef26aeefd5299203995aa3733d25525b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef26aeefd5299203995aa3733d25525b"></a>
oss_wr&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (oss_wr &amp;&amp;lhs, std::string str)</td></tr>
<tr class="separator:aef26aeefd5299203995aa3733d25525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717c7a06002e2d309d76eaf5c05a4f28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a717c7a06002e2d309d76eaf5c05a4f28"></a>
oss_wr&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (oss_wr &amp;&amp;lhs, const char *str)</td></tr>
<tr class="separator:a717c7a06002e2d309d76eaf5c05a4f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56abb51f6a9aec9ed8d1abb736adc064"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56abb51f6a9aec9ed8d1abb736adc064"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56abb51f6a9aec9ed8d1abb736adc064"><td class="memTemplItemLeft" align="right" valign="top">oss_wr&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (oss_wr &amp;&amp;lhs, T rhs)</td></tr>
<tr class="separator:a56abb51f6a9aec9ed8d1abb736adc064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65859efc090932630d14b226b9c9624"><td class="memItemLeft" align="right" valign="top">detail::match_helper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ad65859efc090932630d14b226b9c9624">match</a> (<a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ad65859efc090932630d14b226b9c9624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression.  <a href="#ad65859efc090932630d14b226b9c9624">More...</a><br/></td></tr>
<tr class="separator:ad65859efc090932630d14b226b9c9624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa18a8117e9022caea2b0606c11ebbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaa18a8117e9022caea2b0606c11ebbc"><td class="memTemplItemLeft" align="right" valign="top">detail::match_helper&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#adaa18a8117e9022caea2b0606c11ebbc">match</a> (T &amp;&amp;what)</td></tr>
<tr class="memdesc:adaa18a8117e9022caea2b0606c11ebbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression.  <a href="#adaa18a8117e9022caea2b0606c11ebbc">More...</a><br/></td></tr>
<tr class="separator:adaa18a8117e9022caea2b0606c11ebbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512c996a6bbaef4f7127218b5513226f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a512c996a6bbaef4f7127218b5513226f"></a>
detail::match_helper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a512c996a6bbaef4f7127218b5513226f">match_split</a> (const std::string &amp;str, char delim, bool keep_empties=false)</td></tr>
<tr class="memdesc:a512c996a6bbaef4f7127218b5513226f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> using <code>delim</code> and match the resulting strings. <br/></td></tr>
<tr class="separator:a512c996a6bbaef4f7127218b5513226f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ca31369f494fd492be6de8bec9d96d"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a63ca31369f494fd492be6de8bec9d96d"><td class="memTemplItemLeft" align="right" valign="top">detail::match_each_helper<br class="typebreak"/>
&lt; InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a63ca31369f494fd492be6de8bec9d96d">match_each</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a63ca31369f494fd492be6de8bec9d96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression that matches each element in range [first, last).  <a href="#a63ca31369f494fd492be6de8bec9d96d">More...</a><br/></td></tr>
<tr class="separator:a63ca31369f494fd492be6de8bec9d96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b5c639c9579b617662e3de649ed0cb"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Projection &gt; </td></tr>
<tr class="memitem:a35b5c639c9579b617662e3de649ed0cb"><td class="memTemplItemLeft" align="right" valign="top">detail::match_each_helper<br class="typebreak"/>
&lt; InputIterator, Projection &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a35b5c639c9579b617662e3de649ed0cb">match_each</a> (InputIterator first, InputIterator last, Projection proj)</td></tr>
<tr class="memdesc:a35b5c639c9579b617662e3de649ed0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression that matches <code>proj(i)</code> for each element <code>i</code> in range [first, last).  <a href="#a35b5c639c9579b617662e3de649ed0cb">More...</a><br/></td></tr>
<tr class="separator:a35b5c639c9579b617662e3de649ed0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5bf86134d84a11926891e241b2f209"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b5bf86134d84a11926891e241b2f209"></a>
template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a6b5bf86134d84a11926891e241b2f209"><td class="memTemplItemLeft" align="right" valign="top">detail::match_for_helper<br class="typebreak"/>
&lt; InputIterator, Predicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred)</td></tr>
<tr class="separator:a6b5bf86134d84a11926891e241b2f209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2514e5f45663a8c671d73f6073372b77"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2514e5f45663a8c671d73f6073372b77"></a>
template&lt;typename InputIterator , typename Predicate , typename Advance &gt; </td></tr>
<tr class="memitem:a2514e5f45663a8c671d73f6073372b77"><td class="memTemplItemLeft" align="right" valign="top">detail::match_for_helper<br class="typebreak"/>
&lt; InputIterator, Predicate, <br class="typebreak"/>
Advance &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred, Advance adv)</td></tr>
<tr class="separator:a2514e5f45663a8c671d73f6073372b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31979b2bf7c1ce503faf43dbed6f210b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a31979b2bf7c1ce503faf43dbed6f210b"></a>
template&lt;class InputIterator , class Predicate , class Advance , class Projection &gt; </td></tr>
<tr class="memitem:a31979b2bf7c1ce503faf43dbed6f210b"><td class="memTemplItemLeft" align="right" valign="top">detail::match_for_helper<br class="typebreak"/>
&lt; InputIterator, Predicate, <br class="typebreak"/>
Advance, Projection &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred, Advance adv, Projection pj)</td></tr>
<tr class="separator:a31979b2bf7c1ce503faf43dbed6f210b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1f7de88c500126cd7626401724d10b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e1f7de88c500126cd7626401724d10b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e1f7de88c500126cd7626401724d10b"><td class="memTemplItemLeft" align="right" valign="top">detail::stream_matcher&lt; T, <br class="typebreak"/>
std::istream_iterator&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_stream</b> (std::istream &amp;stream)</td></tr>
<tr class="separator:a9e1f7de88c500126cd7626401724d10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e87041ae91c323107ec8a2cc269762"><td class="memTemplParams" colspan="2"><a class="anchor" id="a92e87041ae91c323107ec8a2cc269762"></a>
template&lt;typename T , typename InputIterator &gt; </td></tr>
<tr class="memitem:a92e87041ae91c323107ec8a2cc269762"><td class="memTemplItemLeft" align="right" valign="top">detail::stream_matcher&lt; T, <br class="typebreak"/>
InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_stream</b> (InputIterator first, InputIterator last)</td></tr>
<tr class="separator:a92e87041ae91c323107ec8a2cc269762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa712d31b5091ed057a8127d781ba3b21"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa712d31b5091ed057a8127d781ba3b21"></a>
template&lt;typename... Lhs, typename... Rhs&gt; </td></tr>
<tr class="memitem:aa712d31b5091ed057a8127d781ba3b21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Lhs..., Rhs...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator,</b> (const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Lhs...&gt; &amp;lhs, const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Rhs...&gt; &amp;rhs)</td></tr>
<tr class="separator:aa712d31b5091ed057a8127d781ba3b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909d6f63fb7e39d1b66679d4585e71eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a909d6f63fb7e39d1b66679d4585e71eb"></a>
template&lt;typename... Cs&gt; </td></tr>
<tr class="memitem:a909d6f63fb7e39d1b66679d4585e71eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (<a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;arg)</td></tr>
<tr class="separator:a909d6f63fb7e39d1b66679d4585e71eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceb36fc3f2adc25b284b702d30e14eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ceb36fc3f2adc25b284b702d30e14eb"></a>
template&lt;typename... Cs&gt; </td></tr>
<tr class="memitem:a8ceb36fc3f2adc25b284b702d30e14eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (<a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&amp;arg)</td></tr>
<tr class="separator:a8ceb36fc3f2adc25b284b702d30e14eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28515cdabde2f2a8d4cb6d342fb68477"><td class="memTemplParams" colspan="2"><a class="anchor" id="a28515cdabde2f2a8d4cb6d342fb68477"></a>
template&lt;typename... Cs&gt; </td></tr>
<tr class="memitem:a28515cdabde2f2a8d4cb6d342fb68477"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;arg)</td></tr>
<tr class="separator:a28515cdabde2f2a8d4cb6d342fb68477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f17df0c43239b3ad2c7aa794ff1616c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8f17df0c43239b3ad2c7aa794ff1616c"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a8f17df0c43239b3ad2c7aa794ff1616c"><td class="memTemplItemLeft" align="right" valign="top">match_expr_from_type_list<br class="typebreak"/>
&lt; typename <a class="el" href="structcppa_1_1util_1_1tl__concat.html">util::tl_concat</a><br class="typebreak"/>
&lt; typename T::cases_list, <br class="typebreak"/>
typename Ts::cases_list... &gt;<br class="typebreak"/>
::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (const T &amp;arg, const Ts &amp;...args)</td></tr>
<tr class="separator:a8f17df0c43239b3ad2c7aa794ff1616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353d8699be6a80737e55a9b746403c6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a353d8699be6a80737e55a9b746403c6e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="namespacecppa.html#a6444f13f198a99e8a11d32a61abf17f1">msg_hdr_cref</a> lhs, <a class="el" href="namespacecppa.html#a6444f13f198a99e8a11d32a61abf17f1">msg_hdr_cref</a> rhs)</td></tr>
<tr class="separator:a353d8699be6a80737e55a9b746403c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31058f68a5f3aa3f5195562e0d129271"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31058f68a5f3aa3f5195562e0d129271"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="namespacecppa.html#a6444f13f198a99e8a11d32a61abf17f1">msg_hdr_cref</a> lhs, <a class="el" href="namespacecppa.html#a6444f13f198a99e8a11d32a61abf17f1">msg_hdr_cref</a> rhs)</td></tr>
<tr class="separator:a31058f68a5f3aa3f5195562e0d129271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7efa4252553fb588e69a45eb59641c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff7efa4252553fb588e69a45eb59641c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>host_id_from_string</b> (const std::string &amp;hash, <a class="el" href="classcppa_1_1node__id.html#aa7e7c469ba17c7cbe6ca7e60c42e9847">node_id::host_id_type</a> &amp;<a class="el" href="classcppa_1_1node__id.html">node_id</a>)</td></tr>
<tr class="separator:aff7efa4252553fb588e69a45eb59641c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e28b15b2076296a8f3d2400e2bcd05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84e28b15b2076296a8f3d2400e2bcd05"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const std::string &amp;hash, const <a class="el" href="classcppa_1_1node__id.html#aa7e7c469ba17c7cbe6ca7e60c42e9847">node_id::host_id_type</a> &amp;<a class="el" href="classcppa_1_1node__id.html">node_id</a>)</td></tr>
<tr class="separator:a84e28b15b2076296a8f3d2400e2bcd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f351347479ac9814d976be5df69d06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0f351347479ac9814d976be5df69d06"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const <a class="el" href="classcppa_1_1node__id.html#aa7e7c469ba17c7cbe6ca7e60c42e9847">node_id::host_id_type</a> &amp;<a class="el" href="classcppa_1_1node__id.html">node_id</a>, const std::string &amp;hash)</td></tr>
<tr class="separator:af0f351347479ac9814d976be5df69d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e103f83664c764b44799700daa1e83e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e103f83664c764b44799700daa1e83e"></a>
const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>uniform_typeid</b> (const std::type_info &amp;)</td></tr>
<tr class="separator:a9e103f83664c764b44799700daa1e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d771014d43e74ef4e17073bebaa2ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1d771014d43e74ef4e17073bebaa2ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> &amp;lhs, const std::type_info &amp;rhs)</td></tr>
<tr class="separator:ac1d771014d43e74ef4e17073bebaa2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccfef6633740c1eff30d983dcfba54f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeccfef6633740c1eff30d983dcfba54f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;lhs, const <a class="el" href="classcppa_1_1object.html">object</a> &amp;rhs)</td></tr>
<tr class="separator:aeccfef6633740c1eff30d983dcfba54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4d0a97a3d502f72511ea3464db9e13"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc4d0a97a3d502f72511ea3464db9e13"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc4d0a97a3d502f72511ea3464db9e13"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (<a class="el" href="classcppa_1_1object.html">object</a> &amp;obj)</td></tr>
<tr class="separator:afc4d0a97a3d502f72511ea3464db9e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafac7c509fc9734cffbf3608e64a04b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aafac7c509fc9734cffbf3608e64a04b5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafac7c509fc9734cffbf3608e64a04b5"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;obj)</td></tr>
<tr class="separator:aafac7c509fc9734cffbf3608e64a04b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af928936d573122345bc0737615f95f33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af928936d573122345bc0737615f95f33"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#af928936d573122345bc0737615f95f33">val</a> ()</td></tr>
<tr class="memdesc:af928936d573122345bc0737615f95f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches any value of type <code>T</code>.  <a href="#af928936d573122345bc0737615f95f33">More...</a><br/></td></tr>
<tr class="separator:af928936d573122345bc0737615f95f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a25d0d9e15f20fe8a0644a1d137d27e90">on</a> (const T &amp;arg, const Ts &amp;...args)</td></tr>
<tr class="memdesc:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches values.  <a href="#a25d0d9e15f20fe8a0644a1d137d27e90">More...</a><br/></td></tr>
<tr class="separator:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8c5c063a1758690748e20c805a76aa"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:acb8c5c063a1758690748e20c805a76aa"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#acb8c5c063a1758690748e20c805a76aa">on</a> ()</td></tr>
<tr class="memdesc:acb8c5c063a1758690748e20c805a76aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches types.  <a href="#acb8c5c063a1758690748e20c805a76aa">More...</a><br/></td></tr>
<tr class="separator:acb8c5c063a1758690748e20c805a76aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1341cd8bd16f4821146053de1093a732"><td class="memTemplParams" colspan="2">template&lt;atom_value... Atoms, typename... Ts&gt; </td></tr>
<tr class="memitem:a1341cd8bd16f4821146053de1093a732"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1341cd8bd16f4821146053de1093a732">on</a> ()</td></tr>
<tr class="memdesc:a1341cd8bd16f4821146053de1093a732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches types.  <a href="#a1341cd8bd16f4821146053de1093a732">More...</a><br/></td></tr>
<tr class="separator:a1341cd8bd16f4821146053de1093a732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b151aa1622c516710fb8f535d40886"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab7b151aa1622c516710fb8f535d40886"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7b151aa1622c516710fb8f535d40886"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab7b151aa1622c516710fb8f535d40886">lift_to_match_expr</a> (T arg)</td></tr>
<tr class="memdesc:ab7b151aa1622c516710fb8f535d40886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>arg</code> to a match expression by returning <code>on_arg_match &gt;&gt; arg</code> if <code>arg</code> is a callable type, otherwise returns <code>arg</code>. <br/></td></tr>
<tr class="separator:ab7b151aa1622c516710fb8f535d40886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb82a73a09096815a7466964ef151d48"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename... Ts&gt; </td></tr>
<tr class="memitem:afb82a73a09096815a7466964ef151d48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#afb82a73a09096815a7466964ef151d48">spawn_cl</a> (const <a class="el" href="classcppa_1_1opencl_1_1program.html">opencl::program</a> &amp;prog, const char *fname, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;local_dims={}, size_t result_size=0)</td></tr>
<tr class="memdesc:afb82a73a09096815a7466964ef151d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>.  <a href="#afb82a73a09096815a7466964ef151d48">More...</a><br/></td></tr>
<tr class="separator:afb82a73a09096815a7466964ef151d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea4c6ddbfaaf38c80cc66125498d337"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename... Ts&gt; </td></tr>
<tr class="memitem:acea4c6ddbfaaf38c80cc66125498d337"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#acea4c6ddbfaaf38c80cc66125498d337">spawn_cl</a> (const char *source, const char *fname, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;local_dims={}, size_t result_size=0)</td></tr>
<tr class="memdesc:acea4c6ddbfaaf38c80cc66125498d337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>.  <a href="#acea4c6ddbfaaf38c80cc66125498d337">More...</a><br/></td></tr>
<tr class="separator:acea4c6ddbfaaf38c80cc66125498d337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d7bfba4838de5879be06a055baef81"><td class="memTemplParams" colspan="2">template&lt;typename MapArgs , typename MapResult &gt; </td></tr>
<tr class="memitem:a70d7bfba4838de5879be06a055baef81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a70d7bfba4838de5879be06a055baef81">spawn_cl</a> (const <a class="el" href="classcppa_1_1opencl_1_1program.html">opencl::program</a> &amp;prog, const char *fname, MapArgs map_args, MapResult map_result, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;local_dims={}, size_t result_size=0)</td></tr>
<tr class="memdesc:a70d7bfba4838de5879be06a055baef81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response.  <a href="#a70d7bfba4838de5879be06a055baef81">More...</a><br/></td></tr>
<tr class="separator:a70d7bfba4838de5879be06a055baef81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab68818f9233383b10fa4ceee161adfc"><td class="memTemplParams" colspan="2">template&lt;typename MapArgs , typename MapResult &gt; </td></tr>
<tr class="memitem:aab68818f9233383b10fa4ceee161adfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aab68818f9233383b10fa4ceee161adfc">spawn_cl</a> (const char *source, const char *fun_name, MapArgs map_args, MapResult map_result, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a050a848622b14ff2d6874ad8f79b6b3e">opencl::dim_vec</a> &amp;local_dims={}, size_t result_size=0)</td></tr>
<tr class="memdesc:aab68818f9233383b10fa4ceee161adfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response.  <a href="#aab68818f9233383b10fa4ceee161adfc">More...</a><br/></td></tr>
<tr class="separator:aab68818f9233383b10fa4ceee161adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203490e67e091f123d0cc6f7884e88c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a203490e67e091f123d0cc6f7884e88c9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a203490e67e091f123d0cc6f7884e88c9"><td class="memTemplItemLeft" align="right" valign="top">detail::rd_arg_functor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a203490e67e091f123d0cc6f7884e88c9">rd_arg</a> (T &amp;storage)</td></tr>
<tr class="memdesc:a203490e67e091f123d0cc6f7884e88c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-hand side of a match expression for a program option reading an argument of type <code>T</code>. <br/></td></tr>
<tr class="separator:a203490e67e091f123d0cc6f7884e88c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab1ebc36e2bddc5cef48f1688af4d7608"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memTemplItemLeft" align="right" valign="top">detail::add_arg_functor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab1ebc36e2bddc5cef48f1688af4d7608">add_arg</a> (std::vector&lt; T &gt; &amp;storage)</td></tr>
<tr class="memdesc:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-hand side of a match expression for a program option adding an argument of type <code>T</code> to <code>storage</code>. <br/></td></tr>
<tr class="separator:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccdbd7a582b0e63258548e836f00c9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ccdbd7a582b0e63258548e836f00c9a"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>set_flag</b> (bool &amp;storage)</td></tr>
<tr class="separator:a6ccdbd7a582b0e63258548e836f00c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e2e610b7d676a86b43b7b5552ea3e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6e2e610b7d676a86b43b7b5552ea3e9"></a>
detail::opt1_rvalue_builder&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ac6e2e610b7d676a86b43b7b5552ea3e9">on_opt1</a> (char short_opt, std::string long_opt, <a class="el" href="namespacecppa.html#ac780fad19465067ad0dc34bc70b5e783">options_description</a> *desc=nullptr, std::string help_text=&quot;&quot;, std::string help_group=&quot;general options&quot;)</td></tr>
<tr class="memdesc:ac6e2e610b7d676a86b43b7b5552ea3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a match expression for a program option with one argument. <br/></td></tr>
<tr class="separator:ac6e2e610b7d676a86b43b7b5552ea3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbb3d478cab709c2eeae7146d73f24c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bbb3d478cab709c2eeae7146d73f24c"></a>
detail::opt0_rvalue_builder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5bbb3d478cab709c2eeae7146d73f24c">on_opt0</a> (char short_opt, std::string long_opt, <a class="el" href="namespacecppa.html#ac780fad19465067ad0dc34bc70b5e783">options_description</a> *desc=nullptr, std::string help_text=&quot;&quot;, std::string help_group=&quot;general options&quot;)</td></tr>
<tr class="memdesc:a5bbb3d478cab709c2eeae7146d73f24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a match expression for a program option with no argument. <br/></td></tr>
<tr class="separator:a5bbb3d478cab709c2eeae7146d73f24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9f8e43fb78f1a6c9afb6700ebe4404"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e9f8e43fb78f1a6c9afb6700ebe4404"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a3e9f8e43fb78f1a6c9afb6700ebe4404">print_desc</a> (<a class="el" href="namespacecppa.html#ac780fad19465067ad0dc34bc70b5e783">options_description</a> *desc, std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:a3e9f8e43fb78f1a6c9afb6700ebe4404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function that prints the help text of <code>desc</code> to <code>out</code>. <br/></td></tr>
<tr class="separator:a3e9f8e43fb78f1a6c9afb6700ebe4404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2216fa186264747a6256d0d21dbf98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb2216fa186264747a6256d0d21dbf98"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aeb2216fa186264747a6256d0d21dbf98">print_desc_and_exit</a> (<a class="el" href="namespacecppa.html#ac780fad19465067ad0dc34bc70b5e783">options_description</a> *desc, std::ostream &amp;out=std::cout, int exit_reason=0)</td></tr>
<tr class="memdesc:aeb2216fa186264747a6256d0d21dbf98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function that prints the help text of <code>desc</code> to <code>out</code> and then calls <code>exit(exit_reason)</code>. <br/></td></tr>
<tr class="separator:aeb2216fa186264747a6256d0d21dbf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98654521009995df429c7cee6444d415"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98654521009995df429c7cee6444d415"></a>
template&lt;int Value&gt; </td></tr>
<tr class="memitem:a98654521009995df429c7cee6444d415"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak"/>
std::integral_constant&lt; int, <br class="typebreak"/>
Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_int_token</b> ()</td></tr>
<tr class="separator:a98654521009995df429c7cee6444d415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5528c744a5047da483f0f67738fce5f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5528c744a5047da483f0f67738fce5f9"></a>
template&lt;bool Value&gt; </td></tr>
<tr class="memitem:a5528c744a5047da483f0f67738fce5f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak"/>
std::integral_constant&lt; bool, <br class="typebreak"/>
Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_bool_token</b> ()</td></tr>
<tr class="separator:a5528c744a5047da483f0f67738fce5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a8c724382cad6efe2ddc779e931f5c"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6a8c724382cad6efe2ddc779e931f5c"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:af6a8c724382cad6efe2ddc779e931f5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1optional__variant.html">optional_variant</a>&lt; T, typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1rm__const__and__ref.html">util::rm_const_and_ref</a>&lt; Ts &gt;<br class="typebreak"/>
::type...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_optional_variant</b> (T value, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:af6a8c724382cad6efe2ddc779e931f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cd987f3ecf6cea41ec75786e51b3d8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab6cd987f3ecf6cea41ec75786e51b3d8"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab6cd987f3ecf6cea41ec75786e51b3d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1optional__variant.html">optional_variant</a>&lt; Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_optional_variant</b> (<a class="el" href="classcppa_1_1optional__variant.html">optional_variant</a>&lt; Ts...&gt; value)</td></tr>
<tr class="separator:ab6cd987f3ecf6cea41ec75786e51b3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608cce08de994ecd153215923e176bd4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a608cce08de994ecd153215923e176bd4"></a>
template&lt;typename... Cases&gt; </td></tr>
<tr class="memitem:a608cce08de994ecd153215923e176bd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1partial__function.html">partial_function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator,</b> (const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cases...&gt; &amp;mexpr, const <a class="el" href="classcppa_1_1partial__function.html">partial_function</a> &amp;pfun)</td></tr>
<tr class="separator:a608cce08de994ecd153215923e176bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88a216f30f87fe11996fb08962f73b7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae88a216f30f87fe11996fb08962f73b7"></a>
template&lt;typename... Cases&gt; </td></tr>
<tr class="memitem:ae88a216f30f87fe11996fb08962f73b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1partial__function.html">partial_function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator,</b> (const <a class="el" href="classcppa_1_1partial__function.html">partial_function</a> &amp;pfun, const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cases...&gt; &amp;mexpr)</td></tr>
<tr class="separator:ae88a216f30f87fe11996fb08962f73b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga5d1de7bc77d88156d0e12e373ab2c613">primitive_type_name</a> (<a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">primitive_type</a> ptype)</td></tr>
<tr class="memdesc:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899" title="Represents the type flag of primitive_variant. ">primitive_type</a> value to its name.  <a href="group___type_system.html#ga5d1de7bc77d88156d0e12e373ab2c613">More...</a><br/></td></tr>
<tr class="separator:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f48cc1f5e2597c4a131d292145f728f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f48cc1f5e2597c4a131d292145f728f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f48cc1f5e2597c4a131d292145f728f"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a> &amp;pv)</td></tr>
<tr class="separator:a1f48cc1f5e2597c4a131d292145f728f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb7eeed8ed3edc2558cf01f26bf86691"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (<a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a> &amp;pv)</td></tr>
<tr class="separator:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090fbee59721028912f07709e6ac8882"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a090fbee59721028912f07709e6ac8882"></a>
logging *&#160;</td><td class="memItemRight" valign="bottom"><b>get_logger</b> ()</td></tr>
<tr class="separator:a090fbee59721028912f07709e6ac8882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c07952d130bd1eb3f5f02a619676bd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c07952d130bd1eb3f5f02a619676bd1"></a>
<a class="el" href="classcppa_1_1scheduler_1_1coordinator.html">scheduler::coordinator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_scheduling_coordinator</b> ()</td></tr>
<tr class="separator:a2c07952d130bd1eb3f5f02a619676bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7767f4842534d531923125cb8f06d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c7767f4842534d531923125cb8f06d9"></a>
detail::group_manager *&#160;</td><td class="memItemRight" valign="bottom"><b>get_group_manager</b> ()</td></tr>
<tr class="separator:a8c7767f4842534d531923125cb8f06d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1761ff3671f8270518ebce7f025db448"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1761ff3671f8270518ebce7f025db448"></a>
detail::actor_registry *&#160;</td><td class="memItemRight" valign="bottom"><b>get_actor_registry</b> ()</td></tr>
<tr class="separator:a1761ff3671f8270518ebce7f025db448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3136f786e4a1ff9cd29c1ce18cd0db5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3136f786e4a1ff9cd29c1ce18cd0db5a"></a>
<a class="el" href="classcppa_1_1io_1_1middleman.html">io::middleman</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_middleman</b> ()</td></tr>
<tr class="separator:a3136f786e4a1ff9cd29c1ce18cd0db5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb30b478f6a94f90dc672d718160781"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eb30b478f6a94f90dc672d718160781"></a>
detail::uniform_type_info_map *&#160;</td><td class="memItemRight" valign="bottom"><b>get_uniform_type_info_map</b> ()</td></tr>
<tr class="separator:a6eb30b478f6a94f90dc672d718160781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef56ad712e7f872723ccf0e992c2095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ef56ad712e7f872723ccf0e992c2095"></a>
detail::abstract_tuple *&#160;</td><td class="memItemRight" valign="bottom"><b>get_tuple_dummy</b> ()</td></tr>
<tr class="separator:a9ef56ad712e7f872723ccf0e992c2095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527ca5ac8ec65b9bbaf0ea123af54782"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a527ca5ac8ec65b9bbaf0ea123af54782"></a>
constexpr <a class="el" href="structcppa_1_1skip__message__t.html">skip_message_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a527ca5ac8ec65b9bbaf0ea123af54782">skip_message</a> ()</td></tr>
<tr class="memdesc:a527ca5ac8ec65b9bbaf0ea123af54782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the runtime system to skip a message when used as message handler, i.e., causes the runtime to leave the message in the mailbox of an actor. <br/></td></tr>
<tr class="separator:a527ca5ac8ec65b9bbaf0ea123af54782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af346e2b573af8954c4ef8fd54941105a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af346e2b573af8954c4ef8fd54941105a"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, <a class="el" href="structcppa_1_1skip__message__t.html">skip_message_t</a>)</td></tr>
<tr class="separator:af346e2b573af8954c4ef8fd54941105a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335a619be5187d7d77b3f5158cef6b66"><td class="memTemplParams" colspan="2"><a class="anchor" id="a335a619be5187d7d77b3f5158cef6b66"></a>
template&lt;class C , spawn_options Os, typename BeforeLaunch , typename... Ts&gt; </td></tr>
<tr class="memitem:a335a619be5187d7d77b3f5158cef6b66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_class</b> (execution_unit *host, BeforeLaunch before_launch_fun, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:a335a619be5187d7d77b3f5158cef6b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f30c5a0e302ab76b019dfb85810c237"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f30c5a0e302ab76b019dfb85810c237"></a>
template&lt;spawn_options Os, typename BeforeLaunch , typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:a1f30c5a0e302ab76b019dfb85810c237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_functor</b> (execution_unit *eu, BeforeLaunch cb, F fun, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:a1f30c5a0e302ab76b019dfb85810c237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a28e93004ce87aa330248e4a5604ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58a28e93004ce87aa330248e4a5604ec"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &amp;what)</td></tr>
<tr class="separator:a58a28e93004ce87aa330248e4a5604ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba13b782ce83d5bf658786130d8df67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ba13b782ce83d5bf658786130d8df67"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="namespacecppa.html#a6444f13f198a99e8a11d32a61abf17f1">msg_hdr_cref</a> what)</td></tr>
<tr class="separator:a5ba13b782ce83d5bf658786130d8df67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2295a70d941fbeee483c0ebc886d4d52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2295a70d941fbeee483c0ebc886d4d52"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1actor.html">actor</a> &amp;what)</td></tr>
<tr class="separator:a2295a70d941fbeee483c0ebc886d4d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a708436f6bd339a66ba9efe0c373aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93a708436f6bd339a66ba9efe0c373aa"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1actor__addr.html">actor_addr</a> &amp;what)</td></tr>
<tr class="separator:a93a708436f6bd339a66ba9efe0c373aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace64ad20578a2389956ca21691fab6a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace64ad20578a2389956ca21691fab6a3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const group &amp;what)</td></tr>
<tr class="separator:ace64ad20578a2389956ca21691fab6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffc1308830a6bd49ab6cf94c4fae75d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ffc1308830a6bd49ab6cf94c4fae75d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1channel.html">channel</a> &amp;what)</td></tr>
<tr class="separator:a5ffc1308830a6bd49ab6cf94c4fae75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcd7b5ec20c2272a4cc5b7823bece88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dcd7b5ec20c2272a4cc5b7823bece88"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1node__id.html">node_id</a> &amp;what)</td></tr>
<tr class="separator:a7dcd7b5ec20c2272a4cc5b7823bece88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1a9477a6e456090448e3f79fc526c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb1a9477a6e456090448e3f79fc526c9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">node_id_ptr</a> &amp;what)</td></tr>
<tr class="separator:adb1a9477a6e456090448e3f79fc526c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7919488dad32bd35a6e461f4ae6d0bd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7919488dad32bd35a6e461f4ae6d0bd7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;what)</td></tr>
<tr class="separator:a7919488dad32bd35a6e461f4ae6d0bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aae38fbd2f412089646134bbb5c75f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60aae38fbd2f412089646134bbb5c75f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a60aae38fbd2f412089646134bbb5c75f">to_verbose_string</a> (const std::exception &amp;e)</td></tr>
<tr class="memdesc:a60aae38fbd2f412089646134bbb5c75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>e</code> to a string including the demangled type of e and <code>e.what()</code>. <br/></td></tr>
<tr class="separator:a60aae38fbd2f412089646134bbb5c75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33344c46529f70febab48161c0c53a68"><td class="memTemplParams" colspan="2">template&lt;typename Types &gt; </td></tr>
<tr class="memitem:a33344c46529f70febab48161c0c53a68"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a33344c46529f70febab48161c0c53a68">get_wildcard_position</a> ()</td></tr>
<tr class="memdesc:a33344c46529f70febab48161c0c53a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of <a class="el" href="structcppa_1_1anything.html">anything</a> from the type list <code>Types</code>.  <a href="#a33344c46529f70febab48161c0c53a68">More...</a><br/></td></tr>
<tr class="separator:a33344c46529f70febab48161c0c53a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f3fbaf504c9a1f71935cea14328b95"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad7f3fbaf504c9a1f71935cea14328b95"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:ad7f3fbaf504c9a1f71935cea14328b95"><td class="memTemplItemLeft" align="right" valign="top">util::tl_at&lt; <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a><br class="typebreak"/>
&lt; Ts...&gt;, N &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a>&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:ad7f3fbaf504c9a1f71935cea14328b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaba7260e3d070dfd846946305e0fbc31e"><td class="memTemplParams" colspan="2">template&lt;class Impl , spawn_options Os = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:gaba7260e3d070dfd846946305e0fbc31e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gaba7260e3d070dfd846946305e0fbc31e">spawn</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gaba7260e3d070dfd846946305e0fbc31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns an actor of type <code>C</code>.  <a href="group___actor_creation.html#gaba7260e3d070dfd846946305e0fbc31e">More...</a><br/></td></tr>
<tr class="separator:gaba7260e3d070dfd846946305e0fbc31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ebbaf95b3beec025d64cb6fa76221e8"><td class="memTemplParams" colspan="2">template&lt;spawn_options Os = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:ga2ebbaf95b3beec025d64cb6fa76221e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga2ebbaf95b3beec025d64cb6fa76221e8">spawn</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga2ebbaf95b3beec025d64cb6fa76221e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new <a class="el" href="classcppa_1_1actor.html">actor</a> that evaluates given arguments.  <a href="group___actor_creation.html#ga2ebbaf95b3beec025d64cb6fa76221e8">More...</a><br/></td></tr>
<tr class="separator:ga2ebbaf95b3beec025d64cb6fa76221e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c2c411c5db83e255ee18f57993471d"><td class="memTemplParams" colspan="2">template&lt;class Impl , spawn_options Os = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:ga02c2c411c5db83e255ee18f57993471d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga02c2c411c5db83e255ee18f57993471d">spawn_in_group</a> (const group &amp;grp, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga02c2c411c5db83e255ee18f57993471d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns an actor of type <code>C</code> that immediately joins <code>grp</code>.  <a href="group___actor_creation.html#ga02c2c411c5db83e255ee18f57993471d">More...</a><br/></td></tr>
<tr class="separator:ga02c2c411c5db83e255ee18f57993471d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91322eea201e1c0ffec28ee11cac1e3"><td class="memTemplParams" colspan="2">template&lt;spawn_options Os = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:gab91322eea201e1c0ffec28ee11cac1e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1actor.html">actor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gab91322eea201e1c0ffec28ee11cac1e3">spawn_in_group</a> (const group &amp;grp, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gab91322eea201e1c0ffec28ee11cac1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new actor that evaluates given arguments and immediately joins <code>grp</code>.  <a href="group___actor_creation.html#gab91322eea201e1c0ffec28ee11cac1e3">More...</a><br/></td></tr>
<tr class="separator:gab91322eea201e1c0ffec28ee11cac1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa38871f50ed4dc03499f0d92e0761614"><td class="memTemplParams" colspan="2">template&lt;class C , spawn_options Os = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:gaa38871f50ed4dc03499f0d92e0761614"><td class="memTemplItemLeft" align="right" valign="top">detail::actor_handle_from_signature_list<br class="typebreak"/>
&lt; typename C::signatures &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gaa38871f50ed4dc03499f0d92e0761614">spawn_typed</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gaa38871f50ed4dc03499f0d92e0761614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a typed actor of type <code>C</code>.  <a href="group___actor_creation.html#gaa38871f50ed4dc03499f0d92e0761614">More...</a><br/></td></tr>
<tr class="separator:gaa38871f50ed4dc03499f0d92e0761614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bbdfd6150cacb8aeca4e949ed67a5db"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1bbdfd6150cacb8aeca4e949ed67a5db"></a>
template&lt;spawn_options Os, typename BeforeLaunch , typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:ga1bbdfd6150cacb8aeca4e949ed67a5db"><td class="memTemplItemLeft" align="right" valign="top">detail::infer_typed_actor_handle<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1get__callable__trait.html">util::get_callable_trait</a>&lt; F &gt;<br class="typebreak"/>
::result_type, typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1tl__head.html">util::tl_head</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1get__callable__trait.html">util::get_callable_trait</a>&lt; F &gt;<br class="typebreak"/>
::arg_types &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_typed_functor</b> (execution_unit *eu, BeforeLaunch bl, F fun, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:ga1bbdfd6150cacb8aeca4e949ed67a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d2de102fac70eadfd5b8552474420f"><td class="memTemplParams" colspan="2">template&lt;spawn_options Os = no_spawn_options, typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:gae5d2de102fac70eadfd5b8552474420f"><td class="memTemplItemLeft" align="right" valign="top">detail::infer_typed_actor_handle<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1get__callable__trait.html">util::get_callable_trait</a>&lt; F &gt;<br class="typebreak"/>
::result_type, typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1tl__head.html">util::tl_head</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structcppa_1_1util_1_1get__callable__trait.html">util::get_callable_trait</a>&lt; F &gt;<br class="typebreak"/>
::arg_types &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gae5d2de102fac70eadfd5b8552474420f">spawn_typed</a> (F fun, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gae5d2de102fac70eadfd5b8552474420f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a typed actor from a functor.  <a href="group___actor_creation.html#gae5d2de102fac70eadfd5b8552474420f">More...</a><br/></td></tr>
<tr class="separator:gae5d2de102fac70eadfd5b8552474420f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a57b0bae78c0c9d497c3636398da1ecbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57b0bae78c0c9d497c3636398da1ecbe"></a>
constexpr <a class="el" href="structcppa_1_1invalid__actor__addr__t.html">invalid_actor_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_actor_addr</b> = <a class="el" href="structcppa_1_1invalid__actor__addr__t.html">invalid_actor_addr_t</a>{}</td></tr>
<tr class="separator:a57b0bae78c0c9d497c3636398da1ecbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3766bb0805c4b771f1b41d77f3f7a946"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3766bb0805c4b771f1b41d77f3f7a946"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_socket</b> = -1</td></tr>
<tr class="separator:a3766bb0805c4b771f1b41d77f3f7a946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68b1f32b051c5cb7bcab4cab683da74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad68b1f32b051c5cb7bcab4cab683da74"></a>
static constexpr none_t&#160;</td><td class="memItemRight" valign="bottom"><b>none</b> = none_t{}</td></tr>
<tr class="separator:ad68b1f32b051c5cb7bcab4cab683da74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fd601df8b1aff0ef276f80a103c5f4e"></a>
constexpr <a class="el" href="structcppa_1_1anything.html">anything</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a6fd601df8b1aff0ef276f80a103c5f4e">any_vals</a> = <a class="el" href="structcppa_1_1anything.html">anything</a>{}</td></tr>
<tr class="memdesc:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches any number of any values. <br/></td></tr>
<tr class="separator:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea202e88a810b28d8c7370c5e058277b"><td class="memItemLeft" align="right" valign="top">constexpr __unspecified__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aea202e88a810b28d8c7370c5e058277b">arg_match</a></td></tr>
<tr class="memdesc:aea202e88a810b28d8c7370c5e058277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches the argument types of a given callback. Must be the last argument to <a class="el" href="namespacecppa.html#a25d0d9e15f20fe8a0644a1d137d27e90">on()</a>.  <a href="#aea202e88a810b28d8c7370c5e058277b">More...</a><br/></td></tr>
<tr class="separator:aea202e88a810b28d8c7370c5e058277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d615a84f0e0e4eede5087ace98adfb"><td class="memItemLeft" align="right" valign="top">constexpr __unspecified__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a46d615a84f0e0e4eede5087ace98adfb">on_arg_match</a></td></tr>
<tr class="memdesc:a46d615a84f0e0e4eede5087ace98adfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression.  <a href="#a46d615a84f0e0e4eede5087ace98adfb">More...</a><br/></td></tr>
<tr class="separator:a46d615a84f0e0e4eede5087ace98adfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241a516282529c45499a49101c35aa74"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>primitive_type_names</b> []</td></tr>
<tr class="separator:a241a516282529c45499a49101c35aa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae748daddf357a1e96ef0b444637b880f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae748daddf357a1e96ef0b444637b880f"></a>
static constexpr unit_t&#160;</td><td class="memItemRight" valign="bottom"><b>unit</b> = unit_t{}</td></tr>
<tr class="separator:ae748daddf357a1e96ef0b444637b880f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a33b8a52fd7db5b67b1ef54590a4915d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33b8a52fd7db5b67b1ef54590a4915d4"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a33b8a52fd7db5b67b1ef54590a4915d4">no_spawn_options</a> = spawn_options::no_flags</td></tr>
<tr class="memdesc:a33b8a52fd7db5b67b1ef54590a4915d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes default settings. <br/></td></tr>
<tr class="separator:a33b8a52fd7db5b67b1ef54590a4915d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f021447f0bf5ed017ecc7246d2a961f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f021447f0bf5ed017ecc7246d2a961f"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5f021447f0bf5ed017ecc7246d2a961f">monitored</a> = spawn_options::monitor_flag</td></tr>
<tr class="memdesc:a5f021447f0bf5ed017ecc7246d2a961f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call <code>self-&gt;monitor(...)</code> immediately after the new actor was spawned. <br/></td></tr>
<tr class="separator:a5f021447f0bf5ed017ecc7246d2a961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9b05086b21ddcff1c3a65314d01923"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b9b05086b21ddcff1c3a65314d01923"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a3b9b05086b21ddcff1c3a65314d01923">linked</a> = spawn_options::link_flag</td></tr>
<tr class="memdesc:a3b9b05086b21ddcff1c3a65314d01923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call <code>self-&gt;link_to(...)</code> immediately after the new actor was spawned. <br/></td></tr>
<tr class="separator:a3b9b05086b21ddcff1c3a65314d01923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3d76a76f39ab461bb855a9317e7be3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e3d76a76f39ab461bb855a9317e7be3"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a3e3d76a76f39ab461bb855a9317e7be3">detached</a> = spawn_options::detach_flag</td></tr>
<tr class="memdesc:a3e3d76a76f39ab461bb855a9317e7be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to opt out of the cooperative scheduling. <br/></td></tr>
<tr class="separator:a3e3d76a76f39ab461bb855a9317e7be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c85d3242470c0e518b8ba2009dadb09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c85d3242470c0e518b8ba2009dadb09"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1c85d3242470c0e518b8ba2009dadb09">hidden</a> = spawn_options::hide_flag</td></tr>
<tr class="memdesc:a1c85d3242470c0e518b8ba2009dadb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the runtime to ignore the new actor in <a class="el" href="namespacecppa.html#a1155a80c876121987be19d4f38c4dacd">await_all_actors_done()</a>. <br/></td></tr>
<tr class="separator:a1c85d3242470c0e518b8ba2009dadb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522ec04cb57018987ad6bfe5df75a023"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a522ec04cb57018987ad6bfe5df75a023"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a522ec04cb57018987ad6bfe5df75a023">blocking_api</a> = spawn_options::blocking_api_flag</td></tr>
<tr class="memdesc:a522ec04cb57018987ad6bfe5df75a023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to opt in to the blocking API of libcppa, i.e., the actor uses a context-switching or thread-based backend instead of the default event-based implementation. <br/></td></tr>
<tr class="separator:a522ec04cb57018987ad6bfe5df75a023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b11e888dffba9f5b2fbca37eb83069"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a47b11e888dffba9f5b2fbca37eb83069">priority_aware</a></td></tr>
<tr class="memdesc:a47b11e888dffba9f5b2fbca37eb83069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to evaluate message priorities.  <a href="#a47b11e888dffba9f5b2fbca37eb83069">More...</a><br/></td></tr>
<tr class="separator:a47b11e888dffba9f5b2fbca37eb83069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Root namespace of libcppa. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9ed5b5aa07c384b14899beae80974d47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a> cppa::atom </td>
          <td>(</td>
          <td class="paramtype">char const (&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[Size]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an atom from given string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String constant representing an atom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A compact representation of <code>str</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a1">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1155a80c876121987be19d4f38c4dacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::await_all_actors_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks execution of this actor until all other actors finished execution. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will cause a deadlock if called from multiple actors. </dd>
<dd>
Do not call this function in cooperatively scheduled actors. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_2_8cpp-example.html#a4">announce_2.cpp</a>, <a class="el" href="announce_3_8cpp-example.html#a5">announce_3.cpp</a>, <a class="el" href="announce_4_8cpp-example.html#a8">announce_4.cpp</a>, <a class="el" href="announce_5_8cpp-example.html#a15">announce_5.cpp</a>, and <a class="el" href="dancing_kirby_8cpp-example.html#a5">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aaa221547ef879ba5b42f7cc7820f90e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T cppa::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string created by <a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> to its original value. </p>
<p>Convenience function that deserializes a value from <code>what</code> and converts the result to <code>T</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>String representation of a serialized value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classcppa_1_1object.html">object</a> instance that contains the deserialized value.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the result is not of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The deserialized value as instance of <code>T</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a33344c46529f70febab48161c0c53a68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Types &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a> cppa::get_wildcard_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the position of <a class="el" href="structcppa_1_1anything.html">anything</a> from the type list <code>Types</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>template parameter pack as <a class="el" href="structcppa_1_1util_1_1type__list.html">type_list</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28cd5b37281764af3f24ba8ca297c2f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> cppa::make_any_tuple </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> containing the elements <code>args</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Values to initialize the tuple elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad65859efc090932630d14b226b9c9624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::match_helper cppa::match </td>
          <td>(</td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Tuple that should be matched against a pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="adaa18a8117e9022caea2b0606c11ebbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_helper cppa::match </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Value that should be matched against a pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a63ca31369f494fd492be6de8bec9d96d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_each_helper&lt;InputIterator&gt; cppa::match_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression that matches each element in range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element (excluded). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a35b5c639c9579b617662e3de649ed0cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename Projection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_each_helper&lt;InputIterator, Projection&gt; cppa::match_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Projection&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression that matches <code>proj(i)</code> for each element <code>i</code> in range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element (excluded). </td></tr>
    <tr><td class="paramname">proj</td><td>Projection or extractor functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9438546a867b3578ae496f205b00ebca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::max_msg_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum size of a message over network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The maximum number of bytes a message may occupy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab092984b6f7e5ee28f07b0b6835e4bdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cppa::max_msg_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the maximum size of messages over network. </p>
<dl class="section return"><dt>Returns</dt><dd>The number maximum number of bytes a message may occupy. </dd></dl>

</div>
</div>
<a class="anchor" id="a25d0d9e15f20fe8a0644a1d137d27e90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::on </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches values. </p>
<p>This overload can be used with the wildcards <a class="el" href="namespacecppa.html#af928936d573122345bc0737615f95f33">val</a>, <a class="el" href="namespacecppa.html#a6fd601df8b1aff0ef276f80a103c5f4e">any_vals</a> and <a class="el" href="namespacecppa.html#aea202e88a810b28d8c7370c5e058277b">arg_match</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a2">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acb8c5c063a1758690748e20c805a76aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches types. </p>
<p>This overload matches types only. The type <a class="el" href="structcppa_1_1anything.html">anything</a> can be used as wildcard to match any number of elements of any types. </p>

</div>
</div>
<a class="anchor" id="a1341cd8bd16f4821146053de1093a732"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atom_value... Atoms, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches types. </p>
<p>This overload matches up to four leading atoms. The type <a class="el" href="structcppa_1_1anything.html">anything</a> can be used as wildcard to match any number of elements of any types. </p>

</div>
</div>
<a class="anchor" id="ab21eb626925475d80514ebfc76a6b7dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish </td>
          <td>(</td>
          <td class="paramtype">actor&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes <code>whom</code> at <code>port</code>. </p>
<p>The connection is automatically closed if the lifetime of <code>whom</code> ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Actor that should be published at <code>port</code>. </td></tr>
    <tr><td class="paramname">port</td><td>Unused TCP port. </td></tr>
    <tr><td class="paramname">addr</td><td>The IP address to listen to, or <code>INADDR_ANY</code> if <code>addr</code> is <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcppa_1_1bind__failure.html" title="Thrown to indicate that an actor publishing failed because the requested port could not be used...">bind_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac16429084be954d051667f2937ae5c93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish </td>
          <td>(</td>
          <td class="paramtype">actor&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; io::acceptor &gt;&#160;</td>
          <td class="paramname"><em>acceptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes <code>whom</code> using <code>acceptor</code> to handle incoming connections. </p>
<p>The connection is automatically closed if the lifetime of <code>whom</code> ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Actor that should be published at <code>port</code>. </td></tr>
    <tr><td class="paramname">acceptor</td><td>Network technology-specific acceptor implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b7cb8011a32265af0252f53b7a4da67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish_local_groups </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes <em>all</em> local groups accessible via network on address <code>addr</code> and <code>port</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcppa_1_1bind__failure.html" title="Thrown to indicate that an actor publishing failed because the requested port could not be used...">bind_failure</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classcppa_1_1network__error.html" title="Thrown to indicate that either an actor publishing failed or libcppa was unable to connect to a remot...">network_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcf7df3d1f181031ee52d9a9d51c869f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1actor.html">actor</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">io::stream_ptr_pair&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to a remote actor via <code>connection</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connection</td><td>A connection to another libcppa process described by a pair of input and output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown when connecting to a typed actor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a944a72f93baaa731fcd939a5b693552b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1actor.html">actor</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor at <code>host</code> on given <code>port</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Valid hostname or IP address. </td></tr>
    <tr><td class="paramname">port</td><td>TCP port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown when connecting to a typed actor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaec44c183aa21e561af941920095f4f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1actor.html">actor</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor at <code>host</code> on given <code>port</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Valid hostname or IP address. </td></tr>
    <tr><td class="paramname">port</td><td>TCP port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown when connecting to a typed actor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb82a73a09096815a7466964ef151d48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1actor.html">actor</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const opencl::program &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>result_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acea4c6ddbfaaf38c80cc66125498d337"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1actor.html">actor</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>result_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, a compilation error occured, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70d7bfba4838de5879be06a055baef81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapArgs , typename MapResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1actor.html">actor</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const opencl::program &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapArgs&#160;</td>
          <td class="paramname"><em>map_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapResult&#160;</td>
          <td class="paramname"><em>map_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>result_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab68818f9233383b10fa4ceee161adfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapArgs , typename MapResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1actor.html">actor</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fun_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapArgs&#160;</td>
          <td class="paramname"><em>map_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapResult&#160;</td>
          <td class="paramname"><em>map_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>result_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, a compilation error occured, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b85364d69c55cc6ac51b2d0780293d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;spawn_options Os = no_spawn_options, typename F  = std::function&lt;void (io::broker*)&gt;, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1actor.html">actor</a> cppa::spawn_io </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns a new, function-based IO actor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>A functor implementing the actor's behavior. </td></tr>
    <tr><td class="paramname">in</td><td>The actor's input stream. </td></tr>
    <tr><td class="paramname">out</td><td>The actor's output stream. </td></tr>
    <tr><td class="paramname">args</td><td>Optional arguments for <code>fun</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Os</td><td>Optional flags to modify <code>spawn</code>'s behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classcppa_1_1actor.html">handle</a> to the spawned actor. </dd></dl>

</div>
</div>
<a class="anchor" id="aced49bb8d987c1484fd446b37714edb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;spawn_options Os = no_spawn_options, typename F  = std::function&lt;void (io::broker*)&gt;, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1actor.html">actor</a> cppa::spawn_io_client </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">io::input_stream_ptr&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">io::output_stream_ptr&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns a new, function-based IO actor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>A functor implementing the actor's behavior. </td></tr>
    <tr><td class="paramname">in</td><td>The actor's input stream. </td></tr>
    <tr><td class="paramname">out</td><td>The actor's output stream. </td></tr>
    <tr><td class="paramname">args</td><td>Optional arguments for <code>fun</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Os</td><td>Optional flags to modify <code>spawn</code>'s behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classcppa_1_1actor.html">handle</a> to the spawned actor. </dd></dl>

</div>
</div>
<a class="anchor" id="a76a9f2873d0e97eb7ceffb6101e8e507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cppa::to_string </td>
          <td>(</td>
          <td class="paramtype">const atom_value &amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>what</code> as a string representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Compact representation of an atom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>what</code> as string. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_4_8cpp-example.html#a2">announce_4.cpp</a>, and <a class="el" href="announce_5_8cpp-example.html#a11">announce_5.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8c36bec69c79ad2680abbb26aaf3107a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Rs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::typed_publish </td>
          <td>(</td>
          <td class="paramtype">typed_actor&lt; Rs...&gt;&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; io::acceptor &gt;&#160;</td>
          <td class="paramname"><em>uptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes <code>whom</code> using <code>acceptor</code> to handle incoming connections. </p>
<p>The connection is automatically closed if the lifetime of <code>whom</code> ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Actor that should be published at <code>port</code>. </td></tr>
    <tr><td class="paramname">acceptor</td><td>Network technology-specific acceptor implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab60d77e0d09df88575d4aaed94d822cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Rs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::typed_publish </td>
          <td>(</td>
          <td class="paramtype">typed_actor&lt; Rs...&gt;&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes <code>whom</code> at <code>port</code>. </p>
<p>The connection is automatically closed if the lifetime of <code>whom</code> ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Actor that should be published at <code>port</code>. </td></tr>
    <tr><td class="paramname">port</td><td>Unused TCP port. </td></tr>
    <tr><td class="paramname">addr</td><td>The IP address to listen to, or <code>INADDR_ANY</code> if <code>addr</code> is <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcppa_1_1bind__failure.html" title="Thrown to indicate that an actor publishing failed because the requested port could not be used...">bind_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1319c0de9f9a711b892897e86395252"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::typed_remote_actor_helper&lt;List&gt;::return_type cppa::typed_remote_actor </td>
          <td>(</td>
          <td class="paramtype">io::stream_ptr_pair&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to a remote actor via <code>connection</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connection</td><td>A connection to another libcppa process described by a pair of input and output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown when connecting to a typed actor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01ab57d6901052a5756b072b56f53f2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::typed_remote_actor_helper&lt;List&gt;::return_type cppa::typed_remote_actor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor at <code>host</code> on given <code>port</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Valid hostname or IP address. </td></tr>
    <tr><td class="paramname">port</td><td>TCP port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown when connecting to a typed actor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac07202c8ac584a09538d39b2f1ef7de3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::typed_remote_actor_helper&lt;List&gt;::return_type cppa::typed_remote_actor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor at <code>host</code> on given <code>port</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Valid hostname or IP address. </td></tr>
    <tr><td class="paramname">port</td><td>TCP port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown when connecting to a typed actor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af928936d573122345bc0737615f95f33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::val </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wildcard that matches any value of type <code>T</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="">Math Actor Example</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_2_8cpp-example.html#a0">announce_2.cpp</a>, <a class="el" href="announce_3_8cpp-example.html#a0">announce_3.cpp</a>, and <a class="el" href="announce_4_8cpp-example.html#a0">announce_4.cpp</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aea202e88a810b28d8c7370c5e058277b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __unspecified__ cppa::arg_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wildcard that matches the argument types of a given callback. Must be the last argument to <a class="el" href="namespacecppa.html#a25d0d9e15f20fe8a0644a1d137d27e90">on()</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="">Math Actor Example</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a3">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a46d615a84f0e0e4eede5087ace98adfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __unspecified__ cppa::on_arg_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression. </p>
<p>Equal to <code>on(arg_match)</code>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_5_8cpp-example.html#a10">announce_5.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a241a516282529c45499a49101c35aa74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* cppa::primitive_type_names[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;pt_int8&quot;</span>,        <span class="stringliteral">&quot;pt_int16&quot;</span>,       <span class="stringliteral">&quot;pt_int32&quot;</span>,       <span class="stringliteral">&quot;pt_int64&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_uint8&quot;</span>,       <span class="stringliteral">&quot;pt_uint16&quot;</span>,      <span class="stringliteral">&quot;pt_uint32&quot;</span>,      <span class="stringliteral">&quot;pt_uint64&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_float&quot;</span>,       <span class="stringliteral">&quot;pt_double&quot;</span>,      <span class="stringliteral">&quot;pt_long_double&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_u8string&quot;</span>,    <span class="stringliteral">&quot;pt_u16string&quot;</span>,   <span class="stringliteral">&quot;pt_u32string&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_atom&quot;</span>,        <span class="stringliteral">&quot;pt_null&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a47b11e888dffba9f5b2fbca37eb83069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a> cppa::priority_aware</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= spawn_options::priority_aware_flag</div>
<div class="line">                                         + spawn_options::detach_flag</div>
</div><!-- fragment -->
<p>Causes the new actor to evaluate message priorities. </p>
<dl class="section note"><dt>Note</dt><dd>This implicitly causes the actor to run in its own thread. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 4 2014 23:48:00 for libcppa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
